# Java

&emsp;

## 目录

## 第一章[Java配置安装与运行](#第一章-java配置安装与运行)

## 第二章[Java基础语法](#第二章-java基础语法)

### &emsp;2.1[Java主类](#21-java主类)

### &emsp;2.2[数据类型](#22-数据类型)

#### &emsp;&emsp;2.2.1[整数类型](#221-整数类型)

#### &emsp;&emsp;2.2.2[浮点类型](#222-浮点类型)

#### &emsp;&emsp;2.2.3[字符类型](#223-字符类型)

#### &emsp;&emsp;2.2.4[布尔类型](#224-布尔类型)

#### &emsp;&emsp;2.2.5[类型转换](#225-类型转换)

##### &emsp;&emsp;&emsp;2.2.5.1[隐式类型转换](#2251-隐式类型转换)

##### &emsp;&emsp;&emsp;2.2.5.2[强制类型转换](#2252-强制类型转换)

### &emsp;2.3[常量变量](#23-常量变量)

#### &emsp;&emsp;2.3.1[标识符](#231-标识符)

#### &emsp;&emsp;2.3.2[声明变量](#232-声明变量)

#### &emsp;&emsp;2.3.3[声明常量（final关键字）](#233-声明常量final关键字)

### &emsp;2.4[运算符](#24-运算符)

#### &emsp;&emsp;2.4.1[赋值运算符](#241-赋值运算符)

#### &emsp;&emsp;2.4.2[算术运算符](#242-算术运算符)

#### &emsp;&emsp;2.4.3[自增自减运算符](#243-自增自减运算符)

#### &emsp;&emsp;2.4.4[比较运算符](#244-比较运算符)

#### &emsp;&emsp;2.4.5[逻辑运算符](#245-逻辑运算符)

#### &emsp;&emsp;2.4.6[位运算符](#246-位运算符)

#### &emsp;&emsp;2.4.7[三元运算符](#247-三元运算符)

### &emsp;2.5[注释](#25-注释)

### &emsp;2.6[输出](#26-输出)

## 第三章[流程控制](#第三章-流程控制)

### &emsp;3.1[条件语句](#31-条件语句)

#### &emsp;&emsp;3.1.1[if语句](#311-if语句)

#### &emsp;&emsp;3.1.2[switch语句](#312-switch语句)

### &emsp;3.2[循环语句](#32-循环语句)

#### &emsp;&emsp;3.2.1[while语句](#321-while语句)

#### &emsp;&emsp;3.2.2[for语句](#322-for语句)

#### &emsp;&emsp;3.2.3[foreach语句](#323-foreach语句)

### &emsp;3.3[循环控制](#33-循环控制)

#### &emsp;&emsp;3.3.1[break语句](#331-break语句)

#### &emsp;&emsp;3.3.2[continue语句](#332-continue语句)

### &emsp;3.4[无条件分支（return关键字）](#34-无条件分支return关键字)

## 第四章[类与对象](#第四章-类与对象)

### &emsp;4.1[类](#41-类)

#### &emsp;&emsp;4.1.1[成员变量](#411-成员变量)

#### &emsp;&emsp;4.1.2[成员方法](#412-成员方法)

#### &emsp;&emsp;4.1.3[权限修饰符](#413-权限修饰符)

#### &emsp;&emsp;4.1.4[局部变量](#414-局部变量)

#### &emsp;&emsp;4.1.5[this关键字](#415-this关键字)

### &emsp;4.2[构造类](#42-构造类)

#### &emsp;&emsp;4.2.1[无参构造类](#421-无参构造类)

#### &emsp;&emsp;4.2.2[有参构造类](#422-有参构造类)

#### &emsp;&emsp;4.2.3[构造函数重载](#423-构造函数重载)

### &emsp;4.3[静态变量、常量和方法（static关键字）](#43-静态变量、常量和方法（static关键字）)

### &emsp;4.4[对象](#44-对象)

#### &emsp;&emsp;4.4.1[创建对象](#441-创建对象)

#### &emsp;&emsp;4.4.2[访问对象](#442-访问对象)

#### &emsp;&emsp;4.4.3[比较对象](#443-比较对象)

#### &emsp;&emsp;4.4.4[销毁对象](#444-销毁对象)

## 第五章[包装类](#第五章-包装类)

### &emsp;5.1[Integer\Long\Short类](#51-Integer\Long\Short类)

#### &emsp;&emsp;5.1.1[构造方法](#511-构造方法)

#### &emsp;&emsp;5.1.2[常用方法](#512-常用方法)

#### &emsp;&emsp;5.1.3[常量](#513-常量)

### &emsp;5.2[Boolean类](#52-Boolean类)

#### &emsp;&emsp;5.2.1[构造方法](#521-构造方法)

#### &emsp;&emsp;5.2.2[常用方法](#522-常用方法)

#### &emsp;&emsp;5.2.3[常量](#523-常量)

### &emsp;5.3[Byte类](#53-Byte)

#### &emsp;&emsp;5.3.1[构造方法](#531-构造方法)

#### &emsp;&emsp;5.3.2[常用方法](#532-常用方法)

#### &emsp;&emsp;5.3.3[常量](#533-常量)

### &emsp;5.4[Character类](#54-Character类)

#### &emsp;&emsp;5.4.1[构造方法](#541-构造方法)

#### &emsp;&emsp;5.4.2[常用方法](#542-常用方法)

#### &emsp;&emsp;5.4.3[常量](#543-常量)

### &emsp;5.5[Double\Float类](#55-Double\Float类)

#### &emsp;&emsp;5.5.1[构造方法](#551-构造方法)

#### &emsp;&emsp;5.5.2[常用方法](#552-常用方法)

#### &emsp;&emsp;5.5.3[常量](#553-常量)

### &emsp;5.6[Number类](#56-Number类)

## 第六章[字符串（String类）](#第六章-字符串string类)

### &emsp;6.1[声明](#61-声明)

### &emsp;6.2[创建与赋值](#62-创建与赋值)

#### &emsp;&emsp;6.2.1[使用字符数组构造](#621-使用字符数组构造)

#### &emsp;&emsp;6.2.2[使用字符串常量构造](#622-使用字符串常量构造)

#### &emsp;&emsp;6.2.3[引用字符串常量](#623-引用字符串常量)

### &emsp;6.3[字符串连接](#63-字符串连接)

#### &emsp;&emsp;6.3.1[连接多字符串](#631-连接多字符串)

#### &emsp;&emsp;6.3.2[连接其他数据类型](#632-连接其他数据类型)

### &emsp;6.4[获取字符串信息](#64-获取字符串信息)

## 第七章[数组（Arrays类）](#第七章-数组arrays类)

## 第八章[数字处理类](#第八章-数字处理类)

## 第九章[类处理](#第九章-类处理)

### &emsp;9.1[继承](#91-继承)

#### &emsp;&emsp;9.1.1[extends和super关键字](#911-extends和super关键字)

#### &emsp;&emsp;9.1.2[final方法与类](#912-final方法与类)

### &emsp;9.2[Object类](#92-Object类)

#### &emsp;&emsp;9.2.1[getClass()](#921-getClass())

#### &emsp;&emsp;9.2.2[toString()](#922-toString())

#### &emsp;&emsp;9.2.3[equals()](#923-equals())

### &emsp;9.3[转型](#93-转型)

#### &emsp;&emsp;9.3.1[向上转型](#931-向上转型)

#### &emsp;&emsp;9.3.2[向下转型](#932-向下转型)

### &emsp;9.4[instanceof关键字](#94-instanceof关键字)

### &emsp;9.5[重载](#95-重载)

### &emsp;9.6[不定长参数](#96-不定长参数)

### &emsp;9.7[多态](#97-多态)

### &emsp;9.8[抽象（abstract关键字）](#98-抽象（abstract关键字）)

### &emsp;9.9[接口（interface和implements关键字）](#99-接口（interface和implements关键字）)

#### &emsp;&emsp;9.9.1[定义和实现](#991-定义和实现)

#### &emsp;&emsp;9.9.2[多继承](#992-多继承)

#### &emsp;&emsp;9.9.3[总结](#993-总结)

#### &emsp;&emsp;9.9.4[默认方法](#994-默认方法)

### &emsp;9.10[类包](#910-类包)

#### &emsp;&emsp;9.10.1[类路径](#9101-类路径)

#### &emsp;&emsp;9.10.2[创建包](#9102-创建包)

#### &emsp;&emsp;9.10.3[导入包（import关键字）](#9103-导入包（import关键字）)

#### &emsp;&emsp;9.10.4[导入静态成员（import关键字）](#9104-导入静态成员（import关键字）)

### &emsp;9.11[内部类](#911-内部类)

#### &emsp;&emsp;9.11.1[成员内部类](#9111-成员内部类)

##### &emsp;&emsp;&emsp;9.11.1.1[说明](#91111-说明)

##### &emsp;&emsp;&emsp;9.11.1.2[内部类向上转型为接口](#91112-内部类向上转型为接口)

##### &emsp;&emsp;&emsp;9.11.1.3[使用this关键字获取内部类与外部类的引用](#91113-使用this关键字获取内部类与外部类的引用)

#### &emsp;&emsp;9.11.2[局部内部类](#9112-局部内部类)

#### &emsp;&emsp;9.11.3[匿名内部类](#9113-匿名内部类)

### &emsp;9.12[获取字符串信息](#912-获取字符串信息)

&emsp;

## [直达底部](#回到目录)

---

&emsp;

## [第一章 Java配置安装与运行](#第一章java配置安装与运行)

$\color{yellowgreen}{JRE}$： Java Runtime Environment JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。  
$\color{yellowgreen}{JDK}$：Java Development Kit JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。  

首先注意类名与文件名保持一致，到目标java文件的目录下，打开cmd窗口。然后输入javac 文件名.java，如果编译成class格式文件成功就接着输入java 类名。  

$\color{yellowgreen}{源文件名}$：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。

&emsp;  

## [第二章 Java基础语法](#第二章java基础语法)

### [2.1 Java主类](#21java主类)

一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。

每一个应用程序都必须包含一个`main()`方法，含有`main()`方法的类一般为主类。`public static void main(String[] args)`方法是程序开始执行的位置。

主类可以含有`main()`方法，不是必要条件，充要条件是带有`public`关键字，仅有主类可以带有`public`关键字，且`main()`方法必须声明为`public static void`。`public`关键字是权限修饰符。

`static`是静态修饰符。知编译器`main()`函数是一个静态函数。也就是说main函数中的代码是存储在静态存储区的，即当定义了类以后这段代码就已经存在了。如果`main()方法`没有使用`static`修饰符，那么编译不会出错，但是如果你试图执行该程序将会报错，提示`main()`方法不存在。因为包含`main()`的类并没有实例化（即没有这个类的对象），所以其`main()`方法也不会存。而使用`static`修饰符则表示该方法是静态的，不需要实例化即可使用。

`void`是返回值修饰符。表名主函数一般返回值是无类型。

`String[]args`是一个字符串类型的数组，是`main()`函数的参数。如C语言的主函数`main()`，虽然其中并没有传入参数，但是实际上操作系统代我们给主函数已经传入了字符串数组类型的参数。Java是显式地传入参数，并转为字符串类型。args就是参数英文的首字母。名字并不重要。

主函数可以被重载，但是JVM只识别`main（String[] args）`，其他都是作为一般函数。这里面的args参数数组变量可以更改，其他都不能更改。
一个java文件中可以包含很多个类，每个类中有且仅有一个主函数，但是每个java文件中可以包含多个主函数，在运行时，需要指定JVM入口是哪个。当如一个类的主函数可以调用另一个类的主函数。

```java
public class Main { //定义主类Main
    public static void main(String[] args) //定义主函数，并定义传入参数的字符串的形参
    {
    for(int i=0;i <args.length;i++)
    System.out.println(args[i]); //在主函数定义本身，功能是打印传入参数
    }
}
public class B { //定义B类
    public static void main(String[] args) //在B类中定义主函数
{
Main c = new Main(); //实例Main的实例c
    String[] b = {"111","222","333"};
    c.main(b); //调用c的main方法。
    }
}
```

由于Main类主函数为静态函数，也可以不用实例化，直接在B类中调用。

一个程序仅有主类可以带有`public`关键字，
成员中的方法可以带有`public`关键字代表共有的方法。如：Main.java

```java
public class Main{
    static String s1 ="hello";
    public static void main(String[]args){
        String s2 = "world";
        System.out.println(s1);
        System.out.println(s2);
    }
}
```

### [2.2 数据类型](#22数据类型)

Java一共有八种基本类型：数值型：byte、short、int、long、float、double和字符型与布尔型。

#### &emsp;[2.2.1 整数类型](#221整数类型)

Java可以用三种形式表示整形数据；十进制、八进制和十六进制。十进制正常表示，八进制前面以0开头，十六进制以0X或者0x开头。
整型数据根据长度不同分为2^8长度的byte，2^16的short，2^32的int，2^64的long。
对于long型值，当赋给值超过int类型的范围时，则需要在数字后加L或者l，表示该数值为长整型，如：long num = 2147483650L。

#### &emsp;[2.2.2 浮点类型](#222浮点类型)

Java中有float单精度浮点数和double双精度浮点数，分别占32,64位，与C语言类似，小数都被默认为双精度类型，但是与C不同的是，如果使用单精度浮点数类型，需要在小数最后添加F或者f，是必须的，可以在double类型的浮点数后加D或者d，也可以不加。
如：

```java
float f1 = 13.34f;
double d1 = 2345.35343d;
```

#### &emsp;[2.2.3 字符类型](#223字符类型)

与C类似，单引号表示字符，双引号表示字符串。
char类型用于存储单个字符，也可以使用数字，因为和C一样，单个字符与unicode表的序号是等价的。如：char x = 'a'; === char x = 97;
因为Java可以把字符作为整数对待，且unicode编码采用无符号编码，所以可以存储65536个字符，可以显示转换为数字：

```java
public class Gess{
    public static void main(String[] args){
        char word = 'd',word2 = '@';
        int p = 23943;
        System.out.println("d在"+(int)word+"@在"+(int)word2);
        System.out.println("23943是"+(char)p);
    }
}
```

Java中的转义字符与C等类似。

#### &emsp;[2.2.4 布尔类型](#224布尔类型)

又叫逻辑类型，使用boolean关键字定义，仅有true和false两个值，不能与整数类型相互转换。

#### &emsp;[2.2.5 类型转换](#225类型转换)

##### &emsp;&emsp;[2.2.5.1 隐式类型转换](#2251隐式类型转换)

`byte<short<int<long<float<double`  
低精度会向高精度转换。

##### &emsp;&emsp;[2.2.5.2 强制类型转换](#2252强制类型转换)

格式：(目标类型)原数据变量  
与C类似。如：`(int)p;`

#### [2.3 常量变量](#23常量变量)

#### &emsp;[2.3.1 标识符](#231标识符)

类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。  
方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。  
Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。  
所有的标识符都应该以字母,美元符`$`、或者下划线`_`开始。  
首字符之后可以是字母,美元符`$`、下划线`_`或数字的任何字符组合。由于Java语言使用unicode标准字符集，所以变量名与字母可以含有中文日文等文字。但是不建议使用。
也不能使用!^&%等特殊符号作为标识符。  
标识符不能为Java关键字和保留字。

#### &emsp;[2.3.2 声明变量](#232声明变量)

$\color{aqua}{定义数据类型}$：类型名 变量名 = 数值；/类型名 变量名;

#### &emsp;[2.3.3 声明常量（final关键字）](#233声明常量final关键字)

在程序中只能被赋值一次。  
$\color{aqua}{格式}$：final 数据类型 常量名称[= 值];  
一般常量名称首字母为大写，且中间以下划线连接，但是并不是必要的。  
当定义的final变量属于成员变量时，就必须定义时设定其初值，否则会出现编译错误。
如：  

```java
public class Part{ //新建类Part
//声明常量PI，此时如果不同时赋值，会出现错误
    static final double PI = 3.14;
    static int age = 23; //声明age变量为int类型并赋值

    public static void main(String[] args){ // 主方法
        final int number; //声明int类型常量number，因为是局部变量，所以可以分开赋值
        number = 1235; //只能赋值一次
        age = 22;
//number = 1236;
        System.out.println("常量：" + PI);
        System.out.println("赋值后的number的值：" + number);
        System.out.println("int类型的变量：" + age);
    }
}
```

final 修饰符通常和 static 修饰符一起使用来创建类常量。

如：  

```java
public class Test{
  final int value = 10;
  // 下面是声明常量的实例
  public static final int BOXWIDTH = 6;
  static final String TITLE = "Manager";
  public void changeValue(){
     value = 12; //将输出一个错误
  }
}
```

那么final关键字和final static的区别在于什么？

就比如将一个数赋值为随机函数的值，所以按道理这个数的值是随机的。如果使用final就代表在这个程序的生命周期中它的值是不变的，运行一次它就是一个固定的值，但是它下一次运行被随机函数赋值的值是不一定的。而如果是使用final static修饰，则代表为其开辟了一个固定空间，在装载就被实例化，所以无论被实例化多少次都会是第一次赋给的值。

如果没有这个需要其实没有特别大的去呗，但是Java中定义全局常量，通常使用public static final修饰，这样就只能在定义时被赋值。

值得注意的是final关键字不仅仅可以定义数值类型变量，也可以定义引用类型变量。一个被定义为final的对象引用只能指向唯一一个对象，不可指向其他对象。但是对象本身的值是可以更改的，如果使引用的对象的值不可以更改就需要使用static final。

#### [2.4 运算符](#24运算符)

#### &emsp;[2.4.1 赋值运算符](#241赋值运算符)

=、+=、-=、*=、/=、%=  
且Java中赋值运算符可以连在一起使用，如：x = y = z =1;

#### &emsp;[2.4.2 算术运算符](#242算术运算符)

+、-、*、/、%  
与C一样，除运算中如果除数或者被除数为负数，结果值的正负依赖于被除数。模运算也是如此：  
a%b=a-(a/b)*b  
5%3=5-(5/3)*3=2  
5%-3=5-(5/-3)*-3=2  
-5%3=-5-(-5/3)*3=-2  
-5%-3=-5-(-5/-3)*-3=-2  
如果操作数中有浮点数则采用的规则为  
a%b=a-(b*q),这里q=int(a/b)  
5.2%3.1=5.2-1*3.1=2.1  
5.2%-3.1=5.2-(-1)*(-3.1)=2.1  
-5.2%3.1=-5.1-(-1)*3.1=-2.1  
-5.2%-3.1=-5.1-(-1)*(-3.1)=-2.1  

#### &emsp;[2.4.3 自增自减运算符](#243自增自减运算符)

++、--  
使用与操作元的位置的影响同C。

#### &emsp;[2.4.4 比较运算符](#244比较运算符)

\>、<、==、>=、<=、!=  
\>、<、>=、<=操作数据为整型，浮点型、字符型，不能为布尔型。  
==、!=操作数据为基本类型数据与引用类型数据。  

#### &emsp;[2.4.5 逻辑运算符](#245逻辑运算符)

&&、&、|、!  
&会判断两边表达式的逻辑值，而&&是针对boolean类型的进行判断，当第一个表达式为false时不再判断第二个。  
逻辑表达式中从左端的表达式可以判断整个表达式的值称为短路，而判断两边的表达式为非短路。&&是短路运算符，&是非短路运算符。  

#### &emsp;[2.4.6 位运算符](#246位运算符)

&、|、~（取反）、^（异或）、<<（左移）、>>（右移）、>>>（无符号右移）  
左移n位就是乘上2^n，右移就是除以2^n。

#### &emsp;[2.4.7 三元运算符](#247三元运算符)

?:;  
也称为条件运算符。与C的三元运算符是一致的。

### [2.5 注释](#25注释)

`//单行注释`  

`/*单行注释*/`  

`/*多行`  
`*注释`  
`*/`  

`/**`  
`文档注释`  
`*/`  

### [2.6 输出](#26输出)

分别有System.out.print、System.out.println、System.out.printf三种基础方法。  
由于Java是类的集合，如果使用方法必须使用类，所以print等方法都在System类中。  
print将它的参数显示在命令窗口，并将输出光标定位在所显示的最后一个字符之后。  
println 将它的参数显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。
printf是格式化输出的形式。

格式符：
'd' 整数 结果被格式化为十进制整数。  
'o' 整数 结果被格式化为八进制整数。  
'x', 'X' 整数 结果被格式化为十六进制整数。  
'e', 'E' 浮点 结果被格式化为用计算机科学记数法表示的十进制数。  
'f' 浮点 结果被格式化为十进制数。  
'g', 'G' 浮点 根据精度和舍入运算后的值，使用计算机科学记数形式或十进制格式对结果进行格式化。  
'a', 'A' 浮点 结果被格式化为带有效位数和指数的十六进制浮点数。  

如：

```java
System.out.print("用print输出i:"+ i);
System.out.println( "用println输出i:"+ i);
System.out.printf("i的值为%d", i);
```

&emsp;  

## [第三章 流程控制](#第三章流程控制)

### [3.1 条件语句](#31条件语句)

#### &emsp;[3.1.1 if语句](#311if语句)

$\color{aqua}{格式}$：  

1. if(条件)语句（单句）  

2. if(条件){语句块}  

3. if(条件){语句块1}  
else{语句块2};

4. if(条件1){语句块1}  
else if(条件2){语句块2};  
……  
else if(条件n){语句块n};  

5. if(条件1){语句块1}  
else if(条件2){语句块2};  
……  
else{语句块n};  

#### &emsp;[3.1.2 switch语句](#312switch语句)

$\color{aqua}{格式}$：  
swtich(表达式)  
{  
    case 常量1：  
        语句块1  
        (break;)  
    ……  
    case 常量n：  
        语句块n  
        (break;)  
    default:  
        语句块n+1  
        (break;)  
}  
switch中表达式的值何常量必须为整型字符型或字符串类型，不可为实数，如3.51。switch语句首先计算表达式的值，如果该值与某个case后的常量值相等，则执行该case后的语句块，直到break。default是可选的，如果都不符合且没有default，那么switch不做处理。
case的值必须不同。

### [3.2 循环语句](#32循环语句)

#### &emsp;[3.2.1 while语句](#321while语句)

$\color{aqua}{格式}$：  
while(条件）{  
语句块  
}  
当条件为真，执行，再返回判断。  

$\color{aqua}{格式}$：  
do{  
语句块  
}  
while(条件);  
首先执行语句再判断，若真再执行，所以语句至少执行一次。且结尾多一个分号。

#### &emsp;[3.2.2 for语句](#322for语句)

$\color{aqua}{格式}$：
for(初始化值;循环条件;修整变量){  
    语句块  
}

#### &emsp;[3.2.3 foreach语句](#323foreach语句)

$\color{aqua}{格式}$：  
for(元素变量x:遍历对象obj){  
引用了x的Java语句  
}  
x仅仅是一个代用的变量，不用初始化用来遍历对象，如Javascript的forin语句。
如：  

```java
public class Pepetition{
    public static void main(String[] args){
        int arr[] = {7,10,1};
        System.out.println("一维数组中的元素为");
        for(int x:arr){
            System.out.println(x);
        }
    }
}
```

### [3.3 循环控制](#33循环控制)

#### &emsp;[3.3.1 break语句](#331break语句)

在swtich语句中break可以跳出分支，在循环结构中break也可以中断循环。  
$\color{aqua}{格式}$：break;  
但是如果是多层循环，那么它仅能跳出该层循环。

如果需要指定跳出的循环，可以使用标签。  
$\color{aqua}{格式}$：  
标签名:for(){  
……  
break 标签名;  
}  
如：

```java
public class BreakOutsideNested{
    public static void main(String[] args){
    Loop:for(int i=0;i<3;i++){
            for(int j=0;j<6;j++){
                if(j==4){
                    break Loop;
                }
                System.out.println("i="+i+" j="+j);
            }
        }
    }
}
>>>>>
i=0 j=0
i=0 j=1
i=0 j=2
i=0 j=3
```

#### &emsp;[3.3.2 continue语句](#332continue语句)

$\color{aqua}{格式}$：continue;  
不是立刻跳出循环体，而是跳出本次循环进行循环体下一个循环。  
在for循环中遇到continue首先执行for语句中的增量部分，再进行条件测试。  
而while语句中直接回到条件测试部分。  

如果需要指定跳出的循环，也可以使用标签。  
$\color{aqua}{格式}$：
标签名:for(){  
……  
continue 标签名;  
}  

### [3.4 无条件分支（return关键字）](#34无条件分支return关键字)

return语句作为一个无条件的分支，无需判断条件即可发生。return语句主要有两个用途:一方面用来表示一个方法返回的值（假定没有void返回值），另一方面是指它导致该方法退出，并返回那个值。根据方法的定义，每一个方法都有返回类型，该类型可以是基本类型，也可以是对象类型，同时每个方法都必须有个结束标志，因此，return起到了这个作用。在返回类型为void的方法里面，有个隐含的return语句，因此，在void方法里面可以省略不写。

&emsp;  

## [第四章 类与对象](#第四章类与对象)

面向对象程序设计有三个特征：封装：将对象的属性和行为封装起来使用户只能使用，而很难操作类内部的数据结构，就避免了外部操作对内部操作的影响；继承：子类继承父类所共有的属性和方法，并具有自己独有的方法；多态：定义抽象类只定义规范而不定义具体操作方式。

### [4.1 类](#41类)

#### &emsp;[4.1.1 成员变量](#411成员变量)

是对象的属性，在类体中定义，在整个类中都有效。  

1. 成员变量定义在类中，在整个类中都可以被访问。
2. 成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。  
3. 成员变量有默认初始化值。

成员变量仅使用一般的变量声明定义，仅能在本类中使用，类外不能使用。

#### &emsp;[4.1.2 成员方法](#412成员方法)

是类对象的行为。
定义全局方法的$\color{aqua}{格式}$：  
权限修饰符 返回值类型 方法名(参数类型 参数名){  
    方法体  
    return 返回值;  
}  
一个成员方法可以有参数，参数可以是对象也可以是基本数据类型，成员方法也可以有返回值也可以不返回，如果需要返回就return返回值，如果无返回值那方法就是void类型。
在成员方法中可以调用其他成员方法和类成员变量。

如果一个方法中含有与成员变量同名的局部变量，那么该方法的访问是针对局部变量而不是类成员变量。
类成员变量和成员方法可以统称为类成员。

#### &emsp;[4.1.3 权限修饰符](#413权限修饰符)

权限修饰符控制着对类和类的成员变量和成员方法的访问。  
`private`仅对于本类是可见的；  
`protected`对于本类可见，还对于同包的其他类与子类是可见的；  
`public`对于本类、同包的类以及其他包的类都是可见的。  
`final`类是不可继承的。  
`abstract`类是抽象类。  
如果没有权限修饰符修饰，就默认为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。  
如果类的权限修饰符与类成员的权限修饰符不同，则全部依照类的权限修饰符。  

#### &emsp;[4.1.4 局部变量](#414局部变量)

在类的方法即成员方法中定义，仅能在成员方法中使用。  

1. 局部变量只定义在局部范围内，如：函数内，语句内等，只在所属的区域有效。
2. 局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。
3. 局部变量没有默认初始化值。局部变量使用时必须赋值或初始化（因为没有默认初始化），否则会编译错误。  

由于局部变量仅在方法使用中有效，所以局部变量使用结束后在互不嵌套的区域可以重新声明一个新的重名的局部变量。互相嵌套的区域则不允许。

#### &emsp;[4.1.5 this关键字](#415this关键字)

`this`代表本类对象的引用，一般用于隐式引用对象的成员变量与方法。
在局部变量或者方法参数覆盖了成员变量时就需要`this`来代表类成员。如：`this.name = name;`
this也可以作为对象来返回：`return this;`

### [4.2 构造类](#42构造类)

类中除了成员方法外，还有用来创建实例对象的构造方法，每当类实例一个对象时都会自动调用该方法。特点：1、构造方法没有返回值 （普通没有返回值的方法需要使用public void 方法名()的方式来定义，但是构造方法不需要`void`来修饰）2、构造方法的名称与本类的名称相同。  
构造方法$\color{aqua}{格式}$：  
构造方法权限修饰符 构造方法名称(参数){  
方法体  
}  
在构造方法中可以为成员变量赋值，这样当实例化一个本类的对象时，相应的成员变量也将被初始化。如果类中没有明确定义构造函数，编译器会自动创建一个不带参数的默认构造方法。所以一种是自己定义的构造方法，一种是编译器默认生成的无参构造方法。  
如：  

```java
public class CreateObject{
    public CreateObject(){ //构造方法
        System.out.println("创建对象");
    }
    public static void main(String[] args){ //主方法
        new CreateObject(); //创建对象
    }
}
```

#### &emsp;[4.2.1 无参构造类](#421无参构造类)

默认构造函数根据类型为对象提供默认值，如：0，null等。

```java
class Student {
    int id;
    String name;

    void display() {
        System.out.println(id + " " + name);
    }

    public static void main(String args[]) {
        Student s1 = new Student3();
        Student s2 = new Student3();
        s1.display();
        s2.display();
    }
}
>>>>>
0 null
0 null
```

#### &emsp;[4.2.2 有参构造类](#422有参构造类)

带有参数的构造函数能动态创建对象：

```java
class Student {
    int id;
    String name;

    Student4(int i, String n) {
        id = i;
        name = n;
    }

    void display() {
        System.out.println(id + " " + name);
    }

    public static void main(String args[]) {
        Student s1 = new Student(111, "Karan");
        Student s2 = new Student(222, "Aryan");
        s1.display();
        s2.display();
    }
}
>>>>>
111 Karan
222 Aryan
```

#### &emsp;[4.2.3 构造函数重载](#423构造函数重载)

构造方法重载是Java中的一种技术，一个类可以有任何数量的参数列表不同的构造函数。编译器通过构造函数参数列表中的参数数量及其类型来区分这些构造函数。
构造函数重载示例:

```java
class Student {
    int id;
    String name;
    int age;

    Student(int i, String n) {
        id = i;
        name = n;
    }

    Student(int i, String n, int a) {
        id = i;
        name = n;
        age = a;
    }

    void display() {
        System.out.println(id + " " + name + " " + age);
    }

    public static void main(String args[]) {
        Student s1 = new Student(111, "Karan");
        Student s2 = new Student(222, "Aryan", 25);
        s1.display();
        s2.display();
    }
}
>>>>>
111 Karan 0
222 Aryan 25
```

### [4.3 静态变量、常量和方法（static关键字）](#43静态变量、常量和方法（static关键字）)

`static`： 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。
方便在没有创建对象的情况下来进行调用（方法/变量）。就是没有`this`的方法，不能调用非静态方法。
被`static`关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。
特点：

1. 想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。
2. 被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。
3. 静态随着类的加载而加载。而且优先于对象存在。

被声明为`static`的变量、常数、方法被称为静态成员。被类所有，所以在本类或者其他类中可以调用静态成员。  
$\color{aqua}{格式}$：类名.静态类成员。  
（可以使用对象.静态成员来调用，但是一般不建议使用该形式，因为容易混淆静态成员和非静态成员。所以虽然实例对象可以寻找到类共有的成员，但是还是建议用类名调用）  
静态变量：也叫为类变量，由static修饰的变量称为静态变量，其实质上就是一个全局变量，可以跨类使用，甚至在整个程序都可以使用，以 类名.静态变量名 的方式。  
如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。不同的对象的实例变量将被分配不同的内存空间， 如果类中的成员变量有类变量，那么所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量，也就是说对象共享类变量。  

实例变量和类变量的区别：

1. 两个变量的生命周期不同  
      实例变量随着实例的创建而存在，随着实例的回收而释放。  
      静态变量随着类的加载而存在，随着类的消失而消失。  

2. 调用方式不同  
      实例变量只能被对象调用。  
      静态变量可以被对象调用，还可以被类名调用。  

3. 数据存储位置不同  
      实例变量存储在堆内存的对象中，所以也叫对象的特有数据。  
      静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。

`static`方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有`this`的，因为它不依附于任何对象，既然都没有对象，就谈不上`this`了，所以在静态方法中使用`this`会报错。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。  
但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。

### [4.4 对象](#44对象)

#### &emsp;[4.4.1 创建对象](#441创建对象)

对象就是类构造的实例，通过`new`关键字构造。（Java中对象和实例可以互换通用）  
$\color{aqua}{格式}$：类名 实例名 = new 构造函数名(参数)  
由于类名和构造函数名是要保持一致的，所以可以这样理解：类名 实例名 = new 类名(参数)
每个对象都是相互独立的。且每个对象都有自己的生命周期，当生命周期结束对象就变成垃圾被回收。  
创建对象的同时会自动调用构造方法中的代码。  
如：`Person person1 = new Person();`

#### &emsp;[4.4.2 访问对象](#442访问对象)

当使用new创建一个对象后，可以使用 对象名.类成员名 来获取对象的属性或行为。  
实际上创建对象时的类名 实例名的实例名是表示对类的引用，该实例名并不会保存一个对象，而是保存一个对象地址，虽然引用与对象是不同的，但是也可以忽略该不同，虽然person1是包含Person类的一个引用，但是可以说是person1是Person的对象。

#### &emsp;[4.4.3 比较对象](#443比较对象)

比较对象可以使用两种方式：

1. ==：比较他们两个变量所指对象是不是同一个，实际比较的是对象的地址，仅有将已创建的对象（其实是地址）赋值给另一个变量，这两个变量使用==比较才相等。
2. `equals()`：是`String()`类的方法，用来比较两个对象的内容是否相同，而不是地址相同。

判断两个变量所指对象是否是同样一个对象，只需要查看是否创建新的对象。

#### &emsp;[4.4.4 销毁对象](#444销毁对象)

在许多方面，Java类似于C++。Java的语法非常类似于C++，Java有类、方法和数据成员；Java的类有构造函数；Java有异常处理。  
但是，如果你使用过C++会发现Java也丢掉一些可能是你熟悉的特性。这些特性之一就是析构函数。取代使用析构函数，Java支持`finalize()`方法。  
与Java不同，C++支持局部对象（基于栈）和全局对象（基于堆）。因为这一双重支持，C++ 也提供了自动构造和析构，这导致了对构造函数和析构函数的调用，（对于堆对象）就是内存的分配和释放。  
在Java中，所有对象都驻留在堆内存，因此局部对象就不存在。结果，Java的设计者觉得不需要析构函数。  
取而代之，Java定义了一个特殊的方法叫做`finalize()`，它提供了C++析构函数的一些功能。但是，`finalize()`并不完全与C++的析构函数一样，并可以假设它会导致一系列的问题。`finalize()`方法作用的一个关键元素是Java的垃圾回收器。

每个对象的生命周期结束后都会变成垃圾，然后被Java的垃圾回收机制回收，而不需要手动去回收（如Javascript中一定要将对象赋值为`null`）  
Java中什么样的对象会称为垃圾：

1. 对象引用超过其范围  
2. 对象被赋值为null

垃圾回收器只能回收那些`new`关键字创建的对象，如果对象不是通过`new`关键字创建的而是通过其他方式获得内存，那是不会被回收的。所以提供了`Object`类的方法`finalize()`方法，是`protected`权限的，可以在自己的类中定义这个方法，如果在类中定义了该方法，那垃圾回收会首先调用该方法，下一次垃圾回收发生时会被回收。  
然而垃圾回收或者`finalize()`方法不一定会发生，如果虚拟机内存不足不会执行。  
所以最后Java提供了强制启动垃圾回收器方法`System.gc()`方法强制垃圾回收器来释放这些对象的内存。

&emsp;  

## [第五章 包装类](#第五章包装类)

为了将基本类型作为对象处理，并连接相关的方法，Java为每个基本类型都提供了包装类。这些类都保存在`java.lang`包中。

### [5.1 Integer\Long\Short类](#51Integer\Long\Short类)

Number类有三个子类：Integer类、long类、Short类，分别封装int、long、short类型。他们的方法基本相同。

#### &emsp;[5.1.1 构造方法](#511构造方法)

1. `Integer\Long\Short(数值)`  
如：`Integer num = new Integer(7);`  
2. `Integer\Long\Short(字符串值)`  
如：`Integer num = new Integer("135");`  

#### &emsp;[5.1.2 引用字符串常量](#512引用字符串常量)

1. `byteValue()`：以byte类型返回值。
2. `compareTo(比较值)`：比较两个数值，如果相等返回0，如果小于比较值就返回负值，大于就返回正值。
3. `equals(比较对象)`：比较两个对象是否相等。
4. `intValue()`：以int类型返回值。
5. `shortVale()`：以short类型返回值。
6. `toString()、toBinaryString()、toHexString()、toOctalString()`：转换为String的十、二、八、十六进制对象。  
7. `valueOf(字符串)`：返回保存指定的String值的对应Number对象。
8. `parseInt(字符串)`：返回保存在字符串中的数字的等价整数值。
9. `longValue()`：以long类型返回值。

#### &emsp;[5.1.3 常量](#513常量)

`MAX_VALUE`：表示该数字类型可取的最大值。
`MIN_VALUE`：表示该数字类型可取的最小值。
`SIZE`：用来以二进制补码形式表示该数字类型值的位数。
`TYPE`：表示该基本类型的Class实例。

以数字类.常量名来获取，如：`int max = Integer.MAX_VALUE;`

### [5.2 Boolean类](#52Boolean类)

#### &emsp;[5.2.1 构造方法](#521构造方法)

1. `Boolean(true/false)`  
创建一个表示该参数的Boolean对象。
2. `Boolean(字符串值)`  
创建一个表示该参数的`Boolean`对象。如果`String`参数不为`null`且忽略大小写时为`true`，则分配一个表示`true`的`Boolean`对象，否则获得一个`false`值的`Boolean`对象。  
如：`Boolean bool = new Boolean("ok");`

#### &emsp;[5.2.2 引用字符串常量](#522常用方法)

1. `booleanValue()`：以`boolean`类型返回值。
2. `equals(比较对象)`：比较两个对象是否相等。
3. `parseBoolean(字符串)`：将字符串解析为`boolean`值。
4. `toString()`：返回表示该`boolean`值的字符串。
5. `valueOf(字符串)`：返回保存指定的`String`值的对应`boolean`值。

#### &emsp;[5.2.3 常量](#523常量)

`TRUE`：对应基值`true`的`Boolean`对象。  
`FALSE`：对应基值`false`的`Boolean`对象。  
`TYPE`：基本类型`boolean`的`Class`实例。  

### [5.3 Byte类](#53Byte类)

#### &emsp;[5.3.1 构造方法](#531构造方法)

1. `Byte(数值)`  
如：`Byte num = new Byte(7);`
2. `Byte(字符串值)`  
如：`Byte num = new Byte("135");`

#### &emsp;[5.3.2 常用方法](#532常用方法)

1. `byteValue();`
2. `compareTo(Byte对象);`
3. `doubleValue();`
4. `intValue();`
5. `parseByte(字符串);`
6. `toString();`
7. `valueOf(字符串);`
8. `equals(Byte对象);`

#### &emsp;[5.3.3 常量](#533常量)

`MAX_VALUE`：表示Byte类型可取的最大值。
`MIN_VALUE`：表示Byte类型可取的最小值。
`SIZE`：用来以二进制补码形式表示Byte值的位数。
`TYPE`：表示该基本类型的Class实例。

### [5.4 Character类](#54Character类)

#### &emsp;[5.4.1 构造方法](#541构造方法)

`Character(字符串值)`
如：`Character num = new Character("135");`
一旦创建，其中的字符串值就不能发生改变。

#### &emsp;[5.4.2 常用方法](#542常用方法)

1. `charValue();`
2. `compareTo(Character对象);`
3. `toString();`
4. `valueOf(字符串);`
5. `equals(Character对象);`
6. `toUpperCase(字符串)`：将字符串参数变为全大写。
7. `toLowerCase(字符串)`：将字符串参数变为全小写。
8. `isUpperCase(字符串)`：判断字符串是否为大写字符。
9. `isLowerCase(字符串)`：判断字符串是否为小写字符。
如：`Character.isUpperCase("DFG")`

#### &emsp;[5.4.3 常量](#543常量)

`CONNECTOR_PUNCTUATION`：返回byte型值，表示Unicode规范中的常规类型“Pc”。
`UNASSIGNED`：返回`byte`值，表示Unicode规范中的常规类别“Cn”。
`TITLECASE_LETTER`：返回`byte`值，表示Unicode规范中的常规类别“Lt”。

### [5.5 Double\Float类](#55Double\Float类)

Number类有两个子类：Double类、Float类，分别封装double、float类型。他们的方法基本相同。

#### &emsp;[5.5.1 构造方法](#551构造方法)

1. `Double\Float(数值)`
如：`Double num = new Double(7);`
2. `Double\Float(字符串值)`
如：`Double num = new Double("135");`

#### &emsp;[5.5.2 常用方法](#552常用方法)

1. `byteValue()`
2. `compareTo(Double/Float对象)`
3. `equals(Double/Float对象)`
4. `intValue()`
5. `isNaN()`
6. `toString()`
7. `valueOf(字符串)`
8. `doubleValue()`
9. `floatValue()`
10. `longValue()`

#### &emsp;[5.5.3 常量](#553常量)

`MAX_EXPONENT`：返回int值，表示有限double/float变量可取的最大指数。
`MIN_EXPONENT`：返回int值，表示有限double/float变量可取的最小指数。
`NEGATIVE_INFINITY`：返回double/float值，表示保存double/float类型的负无穷大值的常量。  
`POSITIVE_INFINITY`：返回double/float值，表示保存double/float类型的正无穷大值的常量。

### [5.6 Number类](#56Number类)

抽象类`Number`类是`BigDecimal`、`BigInteger`、`Byte`、`Double`、`Float`、`Integer`、`Long`、`Short`类的父类，给他们提供转换为相应类型值的方法。抽象类也就是说明它仅作为标准，本身是不能构造相关实例的，这也是面向对象中的多态。
来自于`java.lang.Number`包。

抽象方法：  
`byteValue()`、`intValue()`、`doubleValue()`、`floatValue()`、`longValue()`、`shortValue()`

&emsp;  

## [第六章 字符串（String类）](#第六章字符串string类)

Java中字符串以`String`类的实例来处理。可以通过`java.lang`包中的`String`类创建字符串对象。

### [6.1 声明](#61声明)

字符串必须在双引号中，如："你好"，"a"
声明格式：String 字符串变量名;
字符串必须声明才能使用，如果最开始不知道其值，可以赋为空字符串。

### [6.2 创建与赋值](#62创建与赋值)

#### &emsp;[6.2.1 使用字符数组构造](#621使用字符数组构造)

$\color{aqua}{格式}$：String 变量名=new String(字符数组名);  
如：

```java
char a[] = {'a','b','c'};
String s = new String(a);
```

$\color{aqua}{格式}$：String 变量名= new String(字符数组名,开始截取字符串位置，截取字符串长度);  
可以提取字符数组的一部分。

#### &emsp;[6.2.2 使用字符串常量构造](#622使用字符串常量构造)

$\color{aqua}{格式}$：String 变量名=new String(字符串常量);  
如：  
`String s = new String("nmsl");`

#### &emsp;[6.2.3 引用字符串常量](#623引用字符串常量)

$\color{aqua}{格式}$：  
String 变量名;  
变量名=字符串常量;  
如：  

```java
String s1;
s1="hello world";
```

值得注意的是如果将多个变量都引用同一个字符串常量，那实际上他们是一样的，因为他们都指向同一个实体。

### [6.3 字符串连接](#63字符串连接)

#### &emsp;[6.3.1 连接多字符串](#631连接多字符串)

使用+连接多个字符串。  
且如果一个字符串太长，可以将字符串分开，换行再加上+。

#### &emsp;[6.3.2 连接其他数据类型](#632连接其他数据类型)

同样使用+号连接，会将不同类型的变量统一转换为字符串，因为会自动调用`toString()`方法。
如果我们想在输出的时候先对变量操作，可以使用()将相应的变量包裹，因为()的优先级最高。

### [6.4 获取字符串信息](#64获取字符串信息)

#### &emsp;[6.2.1 引用字符串常量](#621引用字符串常量)

#### &emsp;[6.2.1 引用字符串常量](#621引用字符串常量)

### [5.6 Number类](#56Number类)

&emsp;  

## [第七章 数组（Arrays类）](#第七章数组arrays类)

&emsp;  

## [第八章 数字处理类](#第八章数字处理类)

&emsp;  

## [第九章 类处理](#第九章类处理)

### [9.1 继承](#91继承)

#### &emsp;[9.1.1 extends和super关键字](#911extends和super关键字)

类的继承在于基于某个父类，指定一个新子类，子类拥有父类原有的属性和方法，并有自己独有的属性与方法，甚至可以重写父类的属性方法。  
`extends`关键字说明继承，`super`关键字调用父类。

```java
class Test{
    public Test(){ //构造方法，没有返回值且方法名和类名一致
    }
    protected void doSometing(){ //成员方法
    }
    protected Test doIt(){ //方法返回值为Test类型
        return new Test();
    }
}
class Test2 extends Test{ //定义Test2继承Test类
    public Test2(){ //定义Test构造方法
        super(); //super是父类，super()调用父类
        super.doSomething(); //调用父类成员方法
    }
    public void doSomethingnew(){ //定义子类新方法
    }
    public void doSomething(){ //重写父类方法
    }
    protect Test2 doIt(){ //重写父类方法，返回值为Test2
        return new Test2();
    }
}
```

首先定义了两个类Test和Test2，其中Test2继承了Test类，Test类是Test2的父类。
子类初始化可以连同初始化父类构造方法，既可以在子类中调用`super()`来调用父类构造方法，也可以在子类中使用`super`关键字来调用父类成员。但是子类无法调用`private`权限的成员。  
如果子类和父类的成员方法返回值，方法名称，参数类型与个数都完全相同，不同的仅仅是实现内容，那么这种特殊重写方法为$\color{green}{重构}$。  
当重写父类方法时，修改方法的权限只能从小权限向大权限改，如如果父类成员方法权限为`protected`，那么子类重写方法只能改为`protected`或者`public`。  
当子类重写父类的方法还可以修改返回值类型，但是重写的返回值类型只能时父类同一方法返回值的子类，如返回Test类型值的方法修改后返回类型为Test2就可以，而一般的Int类型就不行，因为不是其原来返回值类型的子类。
Java中一切都以对象的方式进行处理，在继承中，创建一个子类对象，将包含一个父类子对象，这个对象与单用父类构造函数创建的对象是一样的。两者的区别是后者是来自外部，而前者来自子类对象内部。也就是说当实例化子类对象的时候父类对象也同样会被实例化，即实例化子类对象时，Java编译器会在子类的构造方法中自动调用父类的无参构造方法。

如：

```java
class Parent{
    Parent(){
    System.out.println("父类构造方法");
    }
}
class Child extends Parent{
    Child(){
        System.out.println("子类构造方法");
    }
}
public class GrandChild extends Child{
    GrandChild(){
        System.out.println("孙子类构造方法");
    }
    public static void main(String[] args){
        GrandChlid g = new GrandChild();
    }
}
>>>>>
父类构造方法
子类构造方法
孙子类构造方法
```

所以可知当实例化一个子类对象，会首先依次实例化其父类对象。  
在实例化子类对象时，父类无参构造方法会被自动调用，但是有参构造函数不会被自动调用，只能依赖`super`关键字显示地被调用父类构造方法。  
如果使用`finalize()`方法对对象进行显示清理，需要确保子类的`finalize()`方法的最后一个动作是调用父类的`finalize()`方法，以保证父类的垃圾也能被回收。

#### &emsp;[9.1.2 final方法与类](#912final方法与类)

1. `final`参数  
如果声明一个final参数，就代表其参数不能被改变。也就是说传入的参数只能被读取，不能被修改。

2. `final`方法  
父类中的`final`方法可以被子类继承，但是不能被子类重写。同时`final`方法执行等级高于非`final`方法。
声明`final`方法的主要目的是防止该方法的内容被修改。
已知如果一个父类的一个方法被设置为`private`权限，那么子类无法访问该方法。既然无法访问，那就更无法修改，所以一个定义为`private`的方法隐式地指定为`final`权限。
如下所示，使用`final`修饰符声明方法。

```java
public class Test{
    public final void changeName(){
       // 方法体
    }
}
```

3. `final`类  
final类不能被继承，没有类能够继承final类的任何特性。
实例
public final class Test {
   // 类体
}

### [9.2 Object类](#92Object类)

使用`class`关键字定义类时，就开始使用继承，因为在Java中所有的类都继承了`java.lang.Object`类。`Object`类比较特殊，是所有类的父类，是Java类层的最高层。

当创建一个类除非是显示继承其他类，否则就是由java.lang.Object类继承而来的，如String类等，自定义的类也是继承Object类，由于全部的类都是Object类的子类，所以省略extends Object关键字。

由于所有的类都是Object类的子类，所以所有类都可以重写Object类中的方法。
但是getClass()方法、notify()方法、notifyAll()方法、wait()方法等方法不可被重写，因为其为final类型，即用final关键字修饰，不可修改与被继承。

#### &emsp;[9.2.1 getClass()](#921getClass())

是Object类的方法，返回对象执行时的Class实例，然后使用此实例调用getName()方法可以获取改类的名称
语法：getClass().getName();

#### &emsp;[9.2.2 toString()](#922toString())

将一个对象返回为字符串的形式，将返回一个String实例，实际使用时会重写toString方法，为对象提供一个特定的输出模式，当这个类转换为字符串或字符串连接时会自动调用重写的方法。
如：
public class Newclass{
public String toString(){
return "在"+getClass().getName()+"类中重写了toString()方法";
}
public static void main(String[] args){
System.out.println(new Newclass());
}
}
在主函数中打印创建的Newclass对象，应该自动调用该对象的toString()方法，因为在这个对象中重写了toString方法，所以返回的是一串自定义字符串，并写上了当前实例化的类的类名。

#### &emsp;[9.2.3 equals()](#923equals())

在已经定义过的类，如String类、Number类中equals()方法不同于==运算符比较两边的引用，而是比较两边的内容，实际上equals()方法在Object类中默认的功能就是比较其引用是否相同，而在已经包装好的String类等中重写了该方法变为比较内容，但是在自定义的类中，没有定义过这种功能，所以在自定义类中需要同样地重写该函数。

### [9.3 转型](#93转型)

对象类型地转换十分常见，分为向上转型和向下转型，也就是抽象和具体的转换问题。

#### &emsp;[9.3.1 向上转型](#931向上转型)

class Father{
public static void function1(Father f){
}
}
public class Son extends Father{
public static void main(String args[]){
Son s = new Son();
function1(s);
}
}
在这里定义了两个类Father和Son类，Son类继承Father类，Father类中定义了function1的方法，其传递的参数是Father类型的。由于Son类继承Father类，所以也可以在Son类中调用其function1的方法。但是值得注意的是在Son类中调用function1的方法传入的参数不是其定义时的Father类型的参数，而是Son类型的。
这种把子类对象赋值给父类类型的变量的技术就是向上转型。
为什么可以实现向上转型，这就是抽象和具体的转换，抽象就是一类事物所共有的特征，具体就是在共有的特征外还有自己独有的特征。如果一个对象是一个类的子类，那就满足一个类的所有共有特征，还有自己独有的特征，所以是符合特征的，因为抽象的范围比具体的范围更广。由于具体向抽象转型，所以其总是安全的。
这就是多态的思想，在父类上定义所有子类所共有的特征，然后传入子类对象仍能使用，因为子类符合父类标准。

#### &emsp;[9.3.2 向下转型](#932向下转型)

向下转型就是由抽象到具体，但是这种往往会出现问题，如鸽子是鸟，但是鸟不满足鸽子的独有特征。所以可以说子类对象总是父类的实例，但是不能说父类对象总是子类的实例。
如果想向下转型，就必须使用显示类型转换：
格式：(目标类名)变量名;
但是这种向下转型往往有不安全的问题。所以就出现了Java的泛型编程。
为什么需要向下转型？就是因为在实践中虽然将一堆不同类型的类都归于一组，但是获得了抽象性，也丢失了可扩展性。所以向下转型就可以强行获取到原来子类独有的方法。

### [9.4 instanceof关键字](#94instanceof关键字)

当进行向下转型时如果父类不是子类对象的实例，就会发生ClassCastException异常，所以向下转型需要判断父类对象是否为子类对象的实例。
格式:对象的引用变量 instanceof 目标类;
返回true值就是是实例对象，false就是不是。

### [9.5 重载](#95重载)

重载就是在同一个类中允许同时存在一个以上的同名方法，只需要参数个数或者参数类型不同即可。
编译器是根据方法名、参数类型和参数个数以及参数顺序来判断类中的方法是否唯一。（返回值类型不足以判断两个方法的重载）
如：
public class Add{
public static int add(int a,int b){
return a+b;
}
public static double add(double a,double b){
return a+b;
}
public static int add(int a){
return a;
}
public static int add(int a,double b){
return 1;
}
public static int add(double a,int b){
return 1;
}
public static void main(String[] args){
System.out.println("add(int,int)"+add(1,2));
System.out.println("add(double,double)"+add(1.3,2.7));
System.out.println("add(int)"+add(1));
}
}
不同的参数传入函数会实现不同的实现，所以重载的意义就是实现不同参数的适应。

### [9.6 不定长参数](#96不定长参数)

格式：参数数据类型...参数名称
等价于 参数数据类型 参数名称[]；
如int...a等价于int a[];
如：
public static int add(int...a){
int s=0;
for(int i=0,i<a.length；i++)
s+=a[i];
return s;
}
定义不定长参数仍然是可以作为方法的重载。且实用方法类似数组。

### [9.7 多态](#97多态)

利用多态可以抽象到一个抽象类，减少重复代码，使程序具有良好的扩展性，并可以对所有的类对象进行通用的处理。也称为向上转型。就比如定义一个四边形类，平行四边形继承四边形，因为他们求面积的方法是一致的，所以如果单独编写求平行四边形的面积的方法十分麻烦也非常冗余，且只用维护父类方法。这就是多态。

### [9.8 抽象（abstract关键字）](#98抽象（abstract关键字）)

如四边形都是拥有四边，等腰三角形拥有两条相等的三角形，这些描述都是十分合理的，但是对于图形，这样的类就十分抽象，是最顶级的抽的象类，所以就很难用具体的语言进行描述，所以这就是抽象类。

一般父类被定义为抽象类，需要使用该抽象类进行继承和多态处理。由继承机制可以得知，一般越上面的父类就越抽象，在多态机制中不需要实例化抽象类的父类，只需要子类对象，所以在Java中也不能实例化抽象类对象，所以就比如图像类不能抽象出一个具体图形，但是其子类就可以。
最典型的例子就是在Java中没有构造Object类的构造函数，就是因为多态机制它作为抽象类不可实例化。（在JavaScript中就含有，所以JavaScript就不是面向对象的语言，而是基于对象的语言）
格式：
public abstract class 抽象类名{
abstract 权限修饰符 抽象方法名();
}
abstract关键字就是定义抽象类和抽象方法的关键字。

使用abstract关键字定义的类就是抽象类，定义的方法就是抽象方法。
抽象方法没有方法体，它本身没有任何意义，也没有任何作用，除非它在子类被重写，而承载这个抽象方法的抽象类必须被继承（抽象类的存在意义就是被继承）。
抽象方法不能被声明成 final 和 static。

也就是说如果声明一个抽象的方法，那么承载它的类必须是抽象类，只要类中有一个抽象方法，那么它就是抽象类。
当然抽象类中也可以含有非抽象的具体实现的方法。也就是说抽象类可以没有抽象方法。它们双方并不是充分必要条件。当然
抽象类被继承后需要实现其中所有的抽象方法，也就是说要保证相同的方法名称，参数列表和相同返回值类型创建出非抽象方法，也可以是抽象方法。
当继承抽象类的所有子类都需要将抽象类中的抽象方法都覆盖，即重写（因为抽象方法没有意义）

### [9.9 接口（interface和implements关键字）](#99接口（interface和implements关键字）)

接口是抽象类的延伸，可以当作纯粹的抽象类，接口中所有的方法都没有方法体。为什么会出现接口的概念？就是当继承的时候父类的有些方法可能对继承父类的部分子类有效而不是对所有的子类都有效，如多边形的面积求法就不同于三角形和四边形。如果把这部分功能放在父类中被继承，不需要这功能的类仍然需要重写该方法，所以为了让子类继承父类并继承部分类需要的功能，且子类不能同时继承多个父类，所以就出现了接口。让子类继承父类并实现接口。

#### &emsp;[9.9.1 定义和实现](#991定义和实现)

接口定义的格式：
public interface 接口名{
接口内方法，接口中的方法都是抽象方法，不能具体实现功能。
}

实现接口的格式：
public class 类名 implements 接口名{
}
或者
public class 类名 extends 父类名 implements 接口名{
}

在接口中定义的方法必须被声明为public或者abstract形式，其他权限修饰符都不认可，即使不声明也是默认该形式。
且在接口中定义的任何字段都是static和final的。

接口中亦可以有属性，不过这些都是会改变的属性，在子类会重新被重写。

#### &emsp;[9.9.2 多继承](#992多继承)

Java不允许多继承，但是使用接口可以实现多继承，因为一个类可以同时实现多个接口，但是很可能会带来更多的代码量，因为继承一个接口就要实现其所有的方法。
格式：class 类名 implements 接口1,接口2……

同时接口可以继承其他接口：
格式：
interface 接口1 extends 接口2{
}

#### &emsp;[9.9.3 总结](#993总结)

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

接口与类相似点：
一个接口可以有多个方法。
接口文件保存在 .java 结尾的文件中，文件名使用接口名。
接口的字节码文件保存在 .class 结尾的文件中。
接口相应的字节码文件必须在与包名称相匹配的目录结构中。

接口与类的区别：
接口不能用于实例化对象。
接口没有构造方法。
接口中所有的方法必须是抽象方法。
接口不能包含成员变量，除了 static 和 final 变量。
接口不是被类继承了，而是要被类实现。
接口支持多继承。

接口特性
接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

抽象类和接口的区别

1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

#### &emsp;[9.9.4 默认方法](#994默认方法)

Java 8 对接口做了进一步的增强。

a. 在接口中可以添加使用 default 关键字修饰的非抽象方法。即：默认方法（或扩展方法）
b. 接口里可以声明静态方法，并且可以实现。

默认方法（或扩展方法）
Java 8 允许给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做扩展方法（也称为默认方法或虚拟扩展方法或防护方法）。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。
扩展方法不能够重写（也称复写或覆盖） Object 中的方法，却可以重载Object 中的方法。
toString、equals、 hashCode 不能在接口中被覆盖，却可以被重载。
默认方法允许我们在接口里添加新的方法，而不会破坏实现这个接口的已有类的兼容性，也就是说不会强迫实现接口的类实现默认方法。

默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供一个默认的方法实现，所有这个接口的实现类都会通过继承得到这个方法（如果有需要也可以重写这个方法）
如：
interface Defaulable {
    //使用default关键字声明了一个默认方法
     @SuppressLint("NewApi")
     default String myDefalutMethod() {
        return "Default implementation";
    }
}
class DefaultableImpl implements Defaulable {
    //DefaultableImpl实现了Defaulable接口，没有对默认方法做任何修改
}
class OverridableImpl implements Defaulable {
        //OverridableImpl实现了Defaulable接口重写接口的默认实现，提供了自己的实现方法。
        @Override
        public String myDefalutMethod() {
            return "Overridden implementation";
        }
}

JVM平台的接口的默认方法实现是很高效的，并且方法调用的字节码指令支持默认方法。默认方法使已经存在的接口可以修改而不会影响编译的过程。java.util.Collection中添加的额外方法就是最好的例子：stream(), parallelStream(), forEach(), removeIf()

虽然默认方法很强大，但是使用之前一定要仔细考虑是不是真的需要使用默认方法，因为在层级很复杂的情况下很容易引起模糊不清甚至变异错误。

### [9.10 类包](#910类包)

在Java中定义一个类后通过编译就会产生一个.class字节码文件，如果不断扩大程序，很可能会出现命名冲突的问题。所以产生了类包。
Java中每个接口或者类都来自不同的类包。

#### &emsp;[9.10.1 类路径](#9101类路径)

如Math类完整的路径就是java.lang.Math。一个完整的类名应该是包名和类名的组合。
同一个包中的类相互访问可以不用指定包名。
同一个包名中的类可以不必放在同一个位置，只用将CLASSPATH分别指向其具体的位置就行了。

#### &emsp;[9.10.2 创建包](#9102创建包)

格式：package 包名;
在类中指定包名时需要将package表达式放在程序第一行，且必须是非注释的。当使用package关键字为类指定包名后，包名会成为类名中的一部分，所以这个类必须指定全名。
Java包命名必须全部使用小写字母。
在网络共享的包，往往使用创建者的Internet域名的反序作为包名，因为域名独一无二。

#### &emsp;[9.10.3 导入包（import关键字）](#9103导入包（import关键字）)

格式：import 包名;
可以使用：import 包名.*;来导入包中所有的类。
如果不同的类中有相同名字的类，那么使用就必须带有全名。
在程序中添加import关键字时，就开始在CLASSPATH指定的目录中查找符合的.class文件。当import导入一个包中所有类时，不会导入这个包子包的类，如果需要就要单独引用子包。

#### &emsp;[9.10.4 导入静态成员（import关键字）](#9104导入静态成员（import关键字）)

格式：import static 静态成员;
直接导入包中静态的方法，不需要实例化。

### [9.11 内部类](#911内部类)

内部类就是在一个类内部定义的类。内部类可以分为成员内部类，局部内部类，匿名类。
总的来说Java内部类的用法：

1. 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
3. 创建内部类对象的时刻并不依赖于外围类对象的创建。
4. 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
5. 内部类提供了更好的封装，除了该外围类，其他类都不能访问。

#### &emsp;[9.11.1 成员内部类](#9111成员内部类)

在一个类中使用内部类，可以在内部类中直接存取其所在类的私有变量成员。
格式：
权限修饰符 class 外部类名{
权限修饰符 class 内部类名{
……
}
}

##### &emsp;&emsp;[9.11.1.1 说明](#91111说明)

成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。
在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。

内部类的实例一定要绑定在外部类的实例上，如果从外部类中初始化一个内部类对象，那么内部类对象就会被绑定到外部类对象上。内部类初始化方法与其他类初始化方法相同，都是使用new。也就是说需要使用内部类方法必须先实例化外部类，且类使用形式为：
外部类名.内部类名。

如:
public class OuterClass{
innerClass in = new innerClass(); //在外部类实例化内部类对象引用
public void ouf(){
in.inf(); //在外部类方法中调用内部类方法
}
class innerClass{
innerClass(){ //内部类构造方法
}
public void inf(){ //内部类成员方法
}
int y = 0; //定义内部类成员变量
}
public innerClass doit(){ //外部类方法，返回值为内部类引用
//y = 4; //外部类不可以直接访问内部类成员变量
in.y = 4;
return new innerClass();
}
public static void main(String[] args){
OuterClass out = new OuterClass();
//内部类的对象实例化操作必须在外部类或者外部类的静态方法中实现
OuterClass.innerClass in = out.doit();
OuterClass.innerClass in2 = out.new innerClass();
}
}
外部类创建内部类实例与其他类创建对象引用时相同。内部可以访问其外部类成员，但是内部类成员只有内部类内才可以使用，外部类不能直接使用。
如果在外部类和非静态方法之外实例化内部类对象，需要使用外部类，内部类的形式指定该对象的类型。内部类依赖外部类的存在而存在。

内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。所以可以把还没有定义的内部类写在前面。

##### &emsp;&emsp;[9.11.1.2 内部类向上转型为接口](#91112内部类向上转型为接口)

如果将一个权限修饰符为private的内部类向上转型为父类对象，或者直接向上转型为一个接口，那么就可以隐藏内部类具体实现过程。可以在外部提供一个接口，在接口中声明一个方法。如果在实现该接口的内部类中实现该接口的方法，，那么就可以定义多个内部类以不同的方式实现一个接口的同一方法，而一般类是无法多次实现接口中同一方法的。（类似于重载）

interface OutInterface{ //定义一个接口
public void f();
}
public class InterfaceInner{
public static void main(String[] args){
OuterClass out = new OuterClass(); //实例化一个OuterClass2对象
OutInterface outinter = out.doit(); //调用doit()方法，返回一个OutInterface接口
outinter.f(); //调用f()方法
}
}
class OuterClass{ //定义一个内部类实现OutInterface接口
private class InnerClass implements OutInterface{
InnerClass(String s){ //内部类构造方法
System.out.println(s);
}
public void f(){
System.out.println("访问内部类中的f()方法");
}
}
public OutInterface doit(){ //定义一个方法，返回类型为OutInterface接口
return new InnerClass("访问内部类构造方法"); 
}
}
OuterClass类中定义了一个修饰权限为private的内部类，这个内部类实现了OutInterface接口，后修改doit()方法，使该方法返回一个OutInterface接口。由于内部类InnerClass的修饰权限为private，所以只有其父类，即OuterClass类可以访问该内部类，可以访问doit()方法。由于该方法返回的是一个外部接口类型，这个接口可以作为外部使用的接口，其包含一个f()方法。在继承此方法的内部类中实现了此方法，如果某个类继承了外部类，由于内部的权限不能向下转型为内部类InnerClass，同时也不能访问f()方法，但是可以访问接口中的f()方法。如InterfaceInner类中的最后一条语句，接口调用f()方法，可以看出其执行的是内部类的f()方法，也就是对继承该类的子类隐藏了实现方法，隐藏了f()方法的具体实现，仅留下接口和外部类。这也是内部类的基础使用方法。
非内部类不能被声明为private或者protected访问类型。

##### &emsp;&emsp;[9.11.1.3 使用this关键字获取内部类与外部类的引用](#91113使用this关键字获取内部类与外部类的引用)

如果在外部类中定义的成员变量与内部类的成员变量名称相同，可以使用this关键字。
格式：
内部类当前对象的变量：this.变量名
当前对象外部类的变量：外部类名.this.变量名

public class TheSameName{
private int x;
private class Inner{
public void doit(int x){ //传入的是形参x
x++; //调用形参x
this.x++； //调用内部类的变量x
TheSameName.this.x++;
}
}
}

#### &emsp;[9.11.2 局部内部类](#9112局部内部类)

内部类不仅可以在类中定义，也可以在类的局部区域定义，如类的方法，选择和循环语句中等。
对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。
interface OutInterface{ //定义一个接口
}
class OuterClass{
public OutInterface doit(final String x){ 
//doit方法参数设置为final类型，也就是无法修改参数
//定义一个内部类
class InnerClass implements OutInterface{
InnerClass(String s){
s = x;
System.out.println(s);
}
return new InnerClass("doit");
}
}
内部类被定义在doit()方法内部，但是内部类InnerClass是doit()方法的一部分，而不是OuterClass的一部分，所以doit方法外部无法访问内部类额，但是该内部类可以访问外部类和方法的成员。
由于参数x被设置为final类型，所以是无法更改其值，因为其生命周期超越方法的生命周期，被认为是一个常量。

#### &emsp;[9.11.3 匿名内部类](#9113匿名内部类)

图片：
![avatar](https://i.ibb.co/82DzxRK/18.png)

&emsp;  

<!--
6.4.1获取字符串长度（length()）
格式：字符串变量名.length();

6.4.2字符串查找（indexOf()、lastIndexOf()）
6.4.2.1 indexOf()
目标字符串.indexOf(搜索字符串)
返回搜索的字符或字符串首次出现的位置。如果没有搜索到就返回-1。

6.4.2.2 lastIndexOf()
目标字符串.lastIndexOf(搜索字符串)
返回搜索的字符或字符串最后一次出现的位置。如果没有搜索到就返回-1。
如果搜索字符串是空字符串，那么返回就是字符串长度。

6.4.3获取指定索引位置的字符（charAt()）
格式：目标字符串.charAt(索引值);

6.5字符串操作
6.5.1截取字符串（substring()）
格式：目标.substring(开始截取索引值)
返回从指定的索引值开始截取到结尾的子串。
注意字符串中空格占一个索引位置。

格式：目标.substring(开始截取索引值,结束索引值)
返回从指定的索引值开始截取到结束位置的子串。

6.5.2去除空格（trim()）
格式：目标字符串.trim()
返回字符串的副本，忽略前导空格和尾部空格。

6.5.3替换字符串（replace()）
格式：目标字符串.replace(要替换的字符或字符串,用于替换原来字符串的内容)
返回的是一个新字符串，如果要替换的字符或字符串没有出现在目标字符串中，那返回原字符串。
且替换是全局替换。

6.5.4判断字符串开始结尾（startsWith()、endsWith()）
这两个方法是判断字符串是否以指定的内容开始或者结束，其返回值为boolean值。
startsWith()判断当前字符串对象的前缀是否为参数指定的字符串。
格式：目标字符串.startsWith(前缀字符)
endsWith()判断当前字符串对象是否以参数指定的字符串结束。
格式：目标字符串.endsWith(后缀字符)
如：
String s1 = new String("24533");
boolean b = s1.startsWith("24");

6.5.5判断字符串是否相等（equals()、equalslgnoreCase()）
对于字符串对象不能简单地使用==来比较，因为这样比较的是两个对象的地址，而这两个对象如果是不一样的，对象的地址是不同的。所以即使他们的值相等，那么返回的仍然是false。
格式：目标字符串1.equals(目标字符串2)
如果字符串具有相同的字符或者长度，就返回true。

格式：目标字符串1.equalsIgnoreCase(目标字符串2)
如果字符串具有相同的字符或者长度，就返回true。但是字符串不区分大小写。

6.5.6判断字符串顺序（compareTo()）
格式：目标字符串1.compareTo(目标字符串2)
按字典顺序比较两个字符串，基于每个字符的Unicode值，如果目标字符串1位于目标字符串2前面，就返回一个负整数，若是在后面，就返回一个正整数，如果相等就返回0。

6.5.7大小写转换（toLowerCase()、toUpperCase()）
格式：目标字符串.toLowerCase()
全部字母转为小写。
格式：目标字符串.toUpperCase()
全部字母转为大写。
大小写转换时数字与非字符不受影响。

6.5.8分割字符串（split()）
格式：目标字符串.split(分隔符号或者正则表达式)
如果有多高分隔符，可使用|隔开分割符。

格式：目标字符串.split(分隔符号或者正则表达式,切割限定次数)

String str2="a&b&c";
String strs[]=str2.split("&");
   for(String str:strs){
System.out.println(str);
} 
不会输出a,b,c,只有这样处理才可以：
String str2="a&b&c";
String strs[]=str2.split("\\u0024");
   for(String str:strs){
System.out.println(str);
}  
1、如果用“.”作为分隔的话，必须是如下写法：String.split("\\."),这样才能正确的分隔开，不能用String.split(".");
2、如果用“|”作为分隔的话，必须是如下写法：String.split("\\|"),这样才能正确的分隔开，不能用String.split("|");
“.”和“|”都是转义字符，必须得加"\\";

6.6字符串生成器（String-Builder类）
创建成功的字符串对象，长度是固定的，内容无法被改变，虽然使用+可以增长字符串，但是其实是返回一个新的String对象。如果是重复修改字符串会大量占用系统内存，所以增加了字符序列String-Builder类。该类在java.lang.StringBuilder的API。
格式：
StringBuilder 对象名 = new StringBuilder("字符串初始值");
6.6.1 append()
用于向字符串生成器追加内容，可以追加任何数据类型，如int、boolean、另一个字符串生成器等。
格式：字符串生成器名.append(内容);
6.6.2 insert()
用于向字符串生成器插入内容，可以插入任何数据类型，如int、boolean、另一个字符串生成器等。
格式：字符串生成器名.insert(目标索引值,内容);

6.6.3 delete()
用于删除字符串生成器中的字符。
格式：字符串生成器名.delete(起始位置,结束位置);
不包含结束位置。

6.6.4 toString()
将该对象转换为字符串输出。

6.7日期
6.7.1 Date类
java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。

第一个构造函数使用当前日期和时间来初始化对象。
Date( )
第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。
Date(long millisec)

常用方法：
1	boolean after(Date date)
若当调用此方法的Date对象在指定日期之后返回true,否则返回false。
2	boolean before(Date date)
若当调用此方法的Date对象在指定日期之前返回true,否则返回false。
3	Object clone( )
返回此对象的副本。
4	int compareTo(Date date)
比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。
5	int compareTo(Object obj)
若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。
6	boolean equals(Object date)
当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。
7	long getTime( )
返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。
8	int hashCode( )
 返回此对象的哈希码值。
9	void setTime(long time)
 
用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。
10	String toString( )
把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。

6.7.2 Calendar类
我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。

Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。

Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。

创建一个代表系统当前日期的Calendar对象
Calendar c = Calendar.getInstance();//默认是当前日期
创建一个指定日期的Calendar对象
使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。

//创建一个代表2009年6月12日的Calendar对象
Calendar c1 = Calendar.getInstance();
c1.set(2009, 6 - 1, 12);
Calendar类对象字段类型
Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想

常量
Calendar.YEAR	年份
Calendar.MONTH	月份
Calendar.DATE	日期
Calendar.DAY_OF_MONTH	日期，和上面的字段意义完全相同
Calendar.HOUR	12小时制的小时
Calendar.HOUR_OF_DAY	24小时制的小时
Calendar.MINUTE	分钟
Calendar.SECOND	秒
Calendar.DAY_OF_WEEK	星期几

6.7.2.1 set方法
如：
Calendar c1 = Calendar.getInstance();
调用：
public final void set(int year,int month,int date)
c1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12
利用字段类型设置

如果只设定某个字段，例如日期的值，则可以使用如下set方法：
public void set(int field,int value)

把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算

c1.set(Calendar.DATE,10);
把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算

c1.set(Calendar.YEAR,2008);
其他字段属性set的意义以此类推

6.7.2.2 add方法

Calendar c1 = Calendar.getInstance();
把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算

c1.add(Calendar.DATE, 10);
把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算

c1.add(Calendar.DATE, -10);
其他字段属性的add的意义以此类推

Calendar c1 = Calendar.getInstance();
// 获得年份
int year = c1.get(Calendar.YEAR);
// 获得月份
int month = c1.get(Calendar.MONTH) + 1;
// 获得日期
int date = c1.get(Calendar.DATE);
// 获得小时
int hour = c1.get(Calendar.HOUR_OF_DAY);
// 获得分钟
int minute = c1.get(Calendar.MINUTE);
// 获得秒
int second = c1.get(Calendar.SECOND);
// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）
int day = c1.get(Calendar.DAY_OF_WEEK);

6.7.3 GregorianCalendar类
Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。

Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。

构造方法：
1	GregorianCalendar()
在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。
2	GregorianCalendar(int year, int month, int date)
在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar
3	GregorianCalendar(int year, int month, int date, int hour, int minute)
为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。
4	GregorianCalendar(int year, int month, int date, int hour, int minute, int second)
  为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。
5	GregorianCalendar(Locale aLocale)
在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。
6	GregorianCalendar(TimeZone zone)
在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。
7	GregorianCalendar(TimeZone zone, Locale aLocale)
 在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。

常用方法：
1	void add(int field, int amount)
根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。
2	protected void computeFields()
转换UTC毫秒值为时间域值
3	protected void computeTime()
覆盖Calendar ，转换时间域值为UTC毫秒值
4	boolean equals(Object obj)
比较此 GregorianCalendar 与指定的 Object。
5	int get(int field)
获取指定字段的时间值
6	int getActualMaximum(int field)
返回当前日期，给定字段的最大值
7	int getActualMinimum(int field)
返回当前日期，给定字段的最小值
8	int getGreatestMinimum(int field)
 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。
9	Date getGregorianChange()
获得格里高利历的更改日期。
10	int getLeastMaximum(int field)
返回此 GregorianCalendar 实例给定日历字段的最低的最大值
11	int getMaximum(int field)
返回此 GregorianCalendar 实例的给定日历字段的最大值。
12	Date getTime()
获取日历当前时间。
13	long getTimeInMillis()
获取用长整型表示的日历的当前时间
14	TimeZone getTimeZone()
获取时区。
15	int getMinimum(int field)
返回给定字段的最小值。
16	int hashCode()
重写hashCode.
17	boolean isLeapYear(int year)
确定给定的年份是否为闰年。
18	void roll(int field, boolean up)
在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。
19	void set(int field, int value)
用给定的值设置时间字段。
20	void set(int year, int month, int date)
设置年、月、日的值。
21	void set(int year, int month, int date, int hour, int minute)
设置年、月、日、小时、分钟的值。
22	void set(int year, int month, int date, int hour, int minute, int second)
设置年、月、日、小时、分钟、秒的值。
23	void setGregorianChange(Date date)
设置 GregorianCalendar 的更改日期。
24	void setTime(Date date)
用给定的日期设置Calendar的当前时间。
25	void setTimeInMillis(long millis)
用给定的long型毫秒数设置Calendar的当前时间。
26	void setTimeZone(TimeZone value)
用给定时区值设置当前时区。
27	String toString()
返回代表日历的字符串。

如：
import java.util.*;
public class GregorianCalendarDemo {
   public static void main(String args[]) {
      String months[] = {
      "Jan", "Feb", "Mar", "Apr",
      "May", "Jun", "Jul", "Aug",
      "Sep", "Oct", "Nov", "Dec"};
      int year;
      // 初始化 Gregorian 日历
      // 使用当前时间和日期
      // 默认为本地时间和时区
      GregorianCalendar gcalendar = new GregorianCalendar();
      // 显示当前时间和日期的信息
      System.out.print("Date: ");
      System.out.print(months[gcalendar.get(Calendar.MONTH)]);
      System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");
      System.out.println(year = gcalendar.get(Calendar.YEAR));
      System.out.print("Time: ");
      System.out.print(gcalendar.get(Calendar.HOUR) + ":");
      System.out.print(gcalendar.get(Calendar.MINUTE) + ":");
      System.out.println(gcalendar.get(Calendar.SECOND));
      // 测试当前年份是否为闰年
      if(gcalendar.isLeapYear(year)) {
         System.out.println("当前年份是闰年");
      }
      else {
         System.out.println("当前年份不是闰年");
      }
   }
}

>>>>>
Date: Apr 22 2009
Time: 11:25:27
当前年份不是闰年

6.8格式化字符串
String类的静态format()方法用于创建格式化的字符串。
可以和println()配合使用以实现printf()方法的作用。
格式：String.format(格式转换字符串，参数)
参数可以为0，如果参数数量超过了对应格式符的数量，多余的就自动省略。

格式：String.format(格式化应用的语言环境,格式转换字符串，参数)
一般省去语言环境的化就进行本地化，如果该参数为null，就不进行本地化。

格式转换码一般以%开始。

6.8.1日期时间字符串格式化
导入Date包:import java.util.Date
然后需要创建Date对象然后对这个对象格式化然后输出。

1、format()函数
日期格式化转换码：%te：一个月的天数； %tb：语言环境下的月份简称； %tB：语言环境下的月份全称； %ta：语言环境下的星期几简称； %tA：指定语言环境的星期几全称； %tc：包括全部日期和时间信息； %ty：二位年份； %tY:四位年份； %tj：一年中的第几天； %tm：月份； %td：一个月中的第几天；
如：
import java.util.Date;
public class Eval{
public static void main(String[] args){
Date date = new Date();
String year = String.format("%Y",date);
String month = String.format("%tB",date);
String day = String.format("%td",date);
System.out.println("今年："+year+"年");
System.out.println("现在是"+month);
System.out.println("今天是："+day+"号");
}
}

时间格式转换码：%tI：2位数字的12的小时； %tH：2位数字的24的小时； %tl：1到2位数字的12的小时； %tk：1到2位的24的小时； %tM：2位数字的分钟； %tS：2位数字的秒数； %tL：3位数字的毫秒数； %tN：9位数字的微秒数； %tp：指定语言的上午下午标记； %tZ：相对于GMT RFC 82格式的数字时区偏移量； %ts：1970.1.1.00:00:00到现在的秒数； %tQ：1970.1.1.00:00:00到现在的秒数； 
获取时间方式是与获取日期一致的。

日期时间组合格式转换码：%tF：年-月-日 四位年份格式； %tD：月/日/年 两位年份格式； %tc：全部日期和时间信息； %tr：时：分：秒 PM/AM 12时制格式； %tT：时：分：秒 24时制格式； %tR：时：分 24时制格式；

2、SimpleDateFormat类
SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：

如：
import  java.util.*;
import java.text.*;
 
public class DateDemo {
   public static void main(String args[]) {
 
      Date dNow = new Date( );
      SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");
 
      System.out.println("当前时间为: " + ft.format(dNow));
   }
}

这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。

注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。
>>>>>2018-09-06 10:16:34

格式控制符：

字母	描述	示例
G	纪元标记	AD
y	四位年份	2001
M	月份	July or 07
d	一个月的日期	10
h	 A.M./P.M. (1~12)格式小时	12
H	一天中的小时 (0~23)	22
m	分钟数	30
s	秒数	55
S	毫秒数	234
E	星期几	Tuesday
D	一年中的日子	360
F	一个月中第几周的周几	2 (second Wed. in July)
w	一年中第几周	40
W	一个月中第几周	1
a	A.M./P.M. 标记	PM
k	一天中的小时(1~24)	24
K	 A.M./P.M. (0~11)格式小时	10
z	时区	Eastern Standard Time
'	文字定界符	Delimiter
"	单引号	`

3、printf()函数：
printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。

c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007
F "年-月-日"格式 2007-10-27
D "月/日/年"格式 10/27/07
r "HH:MM:SS PM"格式（12时制） 02:25:51 下午
T "HH:MM:SS"格式（24时制） 14:28:16
R "HH:MM"格式（24时制） 14:28

如：
import java.util.Date;
 
public class DateDemo {
 
  public static void main(String args[]) {
     // 初始化 Date 对象
     Date date = new Date();
 
     //c的使用  
    System.out.printf("全部日期和时间信息：%tc%n",date);          
    //f的使用  
    System.out.printf("年-月-日格式：%tF%n",date);  
    //d的使用  
    System.out.printf("月/日/年格式：%tD%n",date);  
    //r的使用  
    System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);  
    //t的使用  
    System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);  
    //R的使用  
    System.out.printf("HH:MM格式（24时制）：%tR",date);  
  }
}
>>>>>
全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  
年-月-日格式：2012-09-10  
月/日/年格式：09/10/12  
HH:MM:SS PM格式（12时制）：10:43:36 上午  
HH:MM:SS格式（24时制）：10:43:36  
HH:MM格式（24时制）：10:43  
如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。

索引必须紧跟在%后面，而且必须以$结束。例如：
import java.util.Date;
public class DateDemo {
   public static void main(String args[]) {
       // 初始化 Date 对象
       Date date = new Date();
       // 使用toString()显示日期和时间
       System.out.printf("%1$s %2$tB %2$td, %2$tY", 
                         "Due date:", date);
   }
}
>>>>>
Due date: February 09, 2014

或者，你可以使用 < 标志。它表明先前被格式化的参数要被再次使用。例如：
import java.util.Date;
public class DateDemo {
   public static void main(String args[]) {
       // 初始化 Date 对象
       Date date = new Date();  
       // 显示格式化时间
       System.out.printf("%s %tB %<te, %<tY", 
                         "Due date:", date);
   }
}

>>>>>
Due date: February 09, 2014
定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如下所示：

实例
import java.util.*;
public class DateDemo {
   public static void main(String args[]) {
       Date date=new Date();                                      
        //b的使用，月份简称  
        String str=String.format(Locale.US,"英文月份简称：%tb",date);       
        System.out.println(str);                                                                              
        System.out.printf("本地月份简称：%tb%n",date);  
        //B的使用，月份全称  
        str=String.format(Locale.US,"英文月份全称：%tB",date);  
        System.out.println(str);  
        System.out.printf("本地月份全称：%tB%n",date);  
        //a的使用，星期简称  
        str=String.format(Locale.US,"英文星期的简称：%ta",date);  
        System.out.println(str);  
        //A的使用，星期全称  
        System.out.printf("本地星期的简称：%tA%n",date);  
        //C的使用，年前两位  
        System.out.printf("年的前两位数字（不足两位前面补0）：%tC%n",date);  
        //y的使用，年后两位  
        System.out.printf("年的后两位数字（不足两位前面补0）：%ty%n",date);  
        //j的使用，一年的天数  
        System.out.printf("一年中的天数（即年的第几天）：%tj%n",date);  
        //m的使用，月份  
        System.out.printf("两位数字的月份（不足两位前面补0）：%tm%n",date);  
        //d的使用，日（二位，不够补零）  
        System.out.printf("两位数字的日（不足两位前面补0）：%td%n",date);  
        //e的使用，日（一位不补零）  
        System.out.printf("月份的日（前面不补0）：%te",date);  
   }
}
>>>>>
英文月份简称：May
本地月份简称：五月
英文月份全称：May
本地月份全称：五月
英文星期的简称：Thu
本地星期的简称：星期四
年的前两位数字（不足两位前面补0）：20
年的后两位数字（不足两位前面补0）：17
一年中的天数（即年的第几天）：124
两位数字的月份（不足两位前面补0）：05
两位数字的日（不足两位前面补0）：04
月份的日（前面不补0）：4

6.8.2常规字符串格式化
%b、%B：转换为布尔类型； %h、%H：转换为散列码； %s、%S：转换为字符串类型； %c、%C：转换为字符类型； %d：转换为十进制整数； %o：转换为八进制整数； %x、%X：转换为十六进制整数； %e：转换为用计算机科学计数法表示的十进制数； %a：转换为带有效位数和指数的十六进制浮点值； %n：转换为行分隔符； %%：转换为%；

6.9正则表达式（regex类）
导入regex包:import java.util.regex
java.util.regex 包主要包括以下三个类：
Pattern 类：pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

6.9.1 常见匹配符号
.	匹配所有单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n）
^regex	正则必须匹配字符串开头
regex$	正则必须匹配字符串结尾
[abc]	复选集定义，匹配字母 a 或 b 或 c
[abc][vz]	复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z
[^abc]	当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c
[a-d1-7]	范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1
XZ	匹配 X 后直接跟着 Z
X|Z	匹配 X 或 Z

6.9.2 元字符
元字符是一个预定义的字符。
\d	匹配一个数字，是 [0-9] 的简写
\D	匹配一个非数字，是 [^0-9] 的简写
\s	匹配一个空格，是 [ \t\n\x0b\r\f] 的简写
\S	匹配一个非空格
\w	匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写
\W	匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w]
6.9.3 限定符
限定符定义了一个元素可以发生的频率。
*	匹配 >=0 个，是 {0,} 的简写	X* 表示匹配零个或多个字母 X，.* 表示匹配任何字符串
+	匹配 >=1 个，是 {1,} 的简写	X+ 表示匹配一个或多个字母 X
?	匹配 1 个或 0 个，是 {0,1} 的简写	X? 表示匹配 0 个或 1 个字母 X
{X}	只匹配 X 个字符	\d{3} 表示匹配 3 个数字，.{10} 表示匹配任何长度是 10 的字符串
{X,Y}	匹配 >=X 且 <=Y 个	\d{1,4} 表示匹配至少 1 个最多 4 个数字
*?	如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式。

6.9.4 分组和反向引用
小括号 () 可以达到对正则表达式进行分组的效果。
模式分组后会在正则表达式中创建反向引用。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。
在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $& 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。

示例：
package com.wuxianjiezh.demo.regex;

public class RegexTest {
    public static void main(String[] args) {
        // 去除单词与 , 和 . 之间的空格
        String Str = "Hello , World .";
        String pattern = "(\\w)(\\s+)([.,])";
        // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.`
        // $1 匹配 `(\w)` 结果为 `o` 和 `d`
        // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格`
        // $3 匹配 `([.,])` 结果为 `,` 和 `.`
        System.out.println(Str.replaceAll(pattern, "$1$3")); // Hello, World.
    }
}
上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\\.]。因为正则对于 [] 中的 .，会自动处理为 [\.]，即普通字符 . 进行匹配。

6.9.4.1 仅分组但无反向引用
当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。

示例：

package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "img.jpg";
        // 分组且创建反向引用
        Pattern pattern = Pattern.compile("(jpg|png)");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
            System.out.println(matcher.group(1));
        }
    }
}
>>>>>
jpg
jpg
若源码改为：
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "img.jpg";
        // 分组但不创建反向引用
        Pattern pattern = Pattern.compile("(?:jpg|png)");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
            System.out.println(matcher.group(1));
        }
    }
}
>>>>>
jpg
Exception in thread "main" java.lang.IndexOutOfBoundsException: No group 1
    at java.util.regex.Matcher.group(Matcher.java:538)
    at com.wuxianjiezh.regex.RegexTest.main(RegexTest.java:15)
6.9.4.2 分组的反向引用副本
Java 中可以在小括号中使用 ?<name> 将小括号中匹配的内容保存为一个名字为 name 的副本。

示例：

package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "@wxj 你好啊";
        Pattern pattern = Pattern.compile("@(?<first>\\w+\\s)"); // 保存一个副本
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
            System.out.println(matcher.group(1));
            System.out.println(matcher.group("first"));
        }
    }
}
>>>>>
@wxj 
wxj 
wxj 
6.9.5 否定先行断言（Negative lookahead）
我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。
否定先行断言模式通过 (?!pattern) 定义。比如，我们匹配后面不是跟着 "b" 的 "a"：
a(?!b)

6.9.6 指定正则表达式的模式
可以在正则的开头指定模式修饰符。
(?i) 使正则忽略大小写。
(?s) 表示单行模式（"single line mode"）使正则的 . 匹配所有字符，包括换行符。
(?m) 表示多行模式（"multi-line mode"），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。

6.9.7 Java中的反斜杠
反斜杠 \ 在 Java 中表示转义字符，这意味着 \ 在 Java 拥有预定义的含义。

这里例举两个特别重要的用法：
在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上 \\，比如匹配 . 时，Java 中要写为 \\.，但对于正则表达式来说就是 \.。
在匹配 \ 时，Java 中要写为 \\\\，但对于正则表达式来说就是 \\。
注意：Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。

6.9.8 易错点示例
[jpg|png] 代表匹配 j 或 p 或 g 或 p 或 n 或 g 中的任意一个字符。
(jpg|png) 代表匹配 jpg 或 png。
因为[]代表或，而()代表分组。

6.9.9内置的字符串正则处理方法
在 Java 中有四个内置的运行正则表达式的方法，分别是 matches()、split())、replaceFirst()、replaceAll()。注意 replace() 方法不支持正则表达式。

方法	描述
s.matches("regex")	当仅且当正则匹配整个字符串时返回 true
s.split("regex")	按匹配的正则表达式切片字符串
s.replaceFirst("regex", "replacement")	替换首次匹配的字符串片段
s.replaceAll("regex", "replacement")	替换所有匹配的字符
示例代码：

package com.wuxianjiezh.regex;
public class RegexTest {
    public static void main(String[] args) {
        System.out.println("wxj".matches("wxj"));
        System.out.println("----------");
        String[] array = "w x j".split("\\s");
        for (String item : array) {
            System.out.println(item);
        }
        System.out.println("----------");
        System.out.println("w x j".replaceFirst("\\s", "-"));
        System.out.println("----------");
        System.out.println("w x j".replaceAll("\\s", "-"));
    }
}
>>>>>
true
----------
w
x
j
----------
w-x j
----------
w-x-j

6.9.10模式和匹配
Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。
第一步，通过正则表达式创建模式对象 Pattern。
第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。
第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。
如：
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String text = "Hello Regex!";
        Pattern pattern = Pattern.compile("\\w+");
        // Java 中忽略大小写，有两种写法：
        // Pattern pattern = Pattern.compile("\\w+", Pattern.CASE_INSENSITIVE);
        // Pattern pattern = Pattern.compile("(?i)\\w+"); // 推荐写法
        Matcher matcher = pattern.matcher(text);
        // 遍例所有匹配的序列
        while (matcher.find()) {
            System.out.print("Start index: " + matcher.start());
            System.out.print(" End index: " + matcher.end() + " ");
            System.out.println(matcher.group());
        }
        // 创建第两个模式，将空格替换为 tab
        Pattern replace = Pattern.compile("\\s+");
        Matcher matcher2 = replace.matcher(text);
        System.out.println(matcher2.replaceAll("\t"));
    }
}
>>>>>
Start index: 0 End index: 5 Hello
Start index: 6 End index: 11 Regex
Hello    Regex!

6.9.11中文的匹配
[\u4e00-\u9fa5]+ 代表匹配中文字。

package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "閑人到人间";
        Pattern pattern = Pattern.compile("[\\u4e00-\\u9fa5]+");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}
>>>>>
閑人到人间

6.9.12 数字范围的匹配
比如，匹配 1990 到 2017。

注意：这里有个新手易范的错误，就是正则 [1990-2017]，实际这个正则只匹配 0 或 1 或 2 或 7 或 9 中的任一个字符。
正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。

正确的匹配方式：
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "1990\n2010\n2017";
        // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出
        // "^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$" 为判断 1990-2017 正确的正则表达式
        Pattern pattern = Pattern.compile("(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}
>>>>>
1990
2010
2017

6.9.13 img标签的匹配
比如，获取图片文件内容，这里我们考虑了一些不规范的 img 标签写法：
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "<img  src='aaa.jpg' /><img src=bbb.png/><img src=\"ccc.png\"/>" +
                "<img src='ddd.exe'/><img src='eee.jpn'/>";
        // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号
        Pattern pattern = Pattern.compile("<img\\s+src=(?:['\"])?(?<src>\\w+.(jpg|png))(?:['\"])?\\s*/>");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group("src"));
        }
    }
}
>>>>>
aaa.jpg
bbb.png
ccc.png

6.9.14 贪婪与非贪婪模式的匹配
比如，获取 div 标签中的文本内容：
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "<div>文章标题</div><div>发布时间</div>";
        // 贪婪模式
        Pattern pattern = Pattern.compile("<div>(?<title>.+)</div>");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group("title"));
        }
        System.out.println("--------------");
        // 非贪婪模式
        pattern = Pattern.compile("<div>(?<title>.+?)</div>");
        matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group("title"));
        }
    }
}
>>>>>
文章标题</div><div>发布时间

第七章 数组（Arrays类）
Java中数组以Arrays类的实例来处理。可以通过java.util包中的Arrays类中的方法来处理数组对象。值得注意的是这个Arrays类是在util中的，证明它本身是一个工具包，所以Arrays是一个工具类，用来处理数组，而不是数组本身，在Java中数组本身就有定义，不需要新的构造函数来构造，这一点与字符串对象是不同的。

7.1一维数组
7.1.1创建一维数组
创建有两种方式：
第一种方式：
格式：数组元素类型[] 数组名;/数组元素类型 数组名[];（不推荐使用）
数组名 = new 数组元素类型[数组元素个数];
当使用new为数组分配内存时，整型数组种各个元素的初始值都是0。
如：
int[] arr;
arr = new int[5];

第二种方式：
格式：数组元素类型 数组名 = new 数组元素类型[数组元素个数];

7.1.2初始化一维数组
初始化有两种方式：
第一种方式：格式：数组元素类型 数组名[] = new 数组元素类型[]{值序列};
第二种方式：格式：数组元素类型 数组名[] = {值序列};
第一种是边创建数组对象边初始化，第二种是已经创立了数组对象再赋值。

7.1.3使用一维数组
通过：数组名[下标]使用，一般使用循环。

7.2二维数组
7.2.1创建二维数组
创建有两种方式：
第一种方式：
格式：数组元素类型[][] 数组名;/数组元素类型 数组名[][];（不推荐使用）
数组名 = new 数组元素类型[行元素个数][列元素个数];

第二种方式：
为每一维数组分配空间。
格式：数组元素类型 数组名 = new 数组元素类型[][];
数组名[0] = new 数组元素类型[行元素个数];
数组名[1] = new 数组元素类型[列元素个数];

7.2.2初始化二维数组
初始化有三种方式：
第一种方式：格式：数组元素类型 数组名[] = new 数组元素类型[][]{值序列};
第二种方式：格式：数组元素类型 数组名[][] = {值序列};
第一种是边创建数组对象边初始化，第二种是已经创立了数组对象再赋值。
第三种方式：格式：数组名[行坐标][列坐标] = 数据；

7.3数组操作
7.3.1数组遍历
一般使用循环。可以通过数组对象的length属性获得数组长度。
一维数组就使用一层循环，如果是n维数组就使用n层循环。
如：
public class Trap{
public statci void main(String[] args){
int b[][] = new int[][]{{1},{2,3},{4,5,6}};
for(int k=0; k<b.length; k++){
for(int c=0; c<b[k].length; c++){
System.out.print(b[k][c]);
}
System.out.println();
}
}
}
>>>>>
1
23
456

也可以使用foreach语句循环输出：
public class Main{ //创建类
    public static void main(String[] args){ //主方法
        int arr[][] = new int[][]{{4,3},{2,1}}; //定义数组对象
        System.out.println("数组中元素是：");
        int i = 0; //设置外层限制计数参数
        for(int x[]:arr){ //外层循环变量设置为arr[][]二维数组中的一维数组x[]；
            i++; //一维数组坐标加一
            int j = 0;
            for(int e:x){
                j++;
                if(i == arr.length && j == x.length){
                    System.out.print(e);
                }else
                    System.out.print(e+"、");
            }
            System.out.println();
        }
    }
}
7.3.2替换元素（fill()）
可以通过Arrays类的fill()静态方法。由于其方法本身的限制，所以一般用于给整个数组初始化同一个值。
格式：Arrays.fill(数组名,同数组类型一致的数值);
将数组元素全部替换为该数值。
fill(数组名,开始填充元素索引,结束填充元素索引,同数组类型一致的数值);

7.3.3数组排序（sort()）
可以通过Arrays类的sort()静态方法。是按照字典顺序进行升序排序。
格式：Arrays.sort(数组名);
Arrays.sort(数组名,开始排序索引,结束排序索引);

7.3.4数组复制（copyOf()、copyOfRange()）
copyOf()格式：copyOf(复制目标数组，复制新数组的长度);
如果新数组长度小于原数组就进行截取，如果大于就使用0填充。
copyOfRange()格式：copyOfRange(复制目标数组，开始复制索引，结束复制索引);
结束复制索引可以大于数组长度，且结束索引复制不包括该索引所在数值。

7.3.5数组查询（binarySearch()）
格式：binarySearch(搜索数组,搜索值);
binarySearch()使用二分法进行搜索。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素的索引。一般使用为了方便需要先使用sort()方法排序。
[1]搜索值是数组元素，从0开始计数，得搜索值的索引值；
[2]搜索值不是数组元素，且在数组范围内，从1开始计数，得“-插入点索引值”；
[3]搜索值不是数组元素，且大于数组内元素，索引值为–(length + 1);
[4]搜索值不是数组元素，且小于数组内元素，索引值为–1。
如：
 int arr [] =newint[]{1,3,4,5,8,9};
Arrays.sort(arr);
int index1 = Arrays.binarySearch(arr,6);
int index2 = Arrays.binarySearch(arr,4);
int index3 = Arrays.binarySearch(arr,0);
int index4 = Arrays.binarySearch(arr,10);
System.out.println("index1 = "+ index1 +", index2 = " + index2 +
", index3 = " + index3 +", index4 = "+ index4);
>>>>>index1= -5, index2 = 2, index3 = -1, index4 = -7
 
格式：bianrySearch(搜索数组,开始搜索索引,结束搜索索引,要搜索的元素);
[1]该搜索键在范围内，且是数组元素，由0开始计数，得搜索值的索引值；
[2]该搜索键在范围内，但不是数组元素，由1开始计数，得“ - 插入点索引值”；
[3]该搜索键不在范围内，且小于范围（数组）内元素，返回–(fromIndex + 1)；
[4]该搜索键不在范围内，且大于范围（数组）内元素，返回–(toIndex + 1)。
如：
int arr [] =newint[]{1,3,4,5,8,9};
System.out.println(arr.length+1);
Arrays.sort(arr);
int index5 = Arrays.binarySearch(arr,1, 4, 6);
int index6 = Arrays.binarySearch(arr,1, 4, 4);
int index7 = Arrays.binarySearch(arr,1, 4 ,2);
int index8 = Arrays.binarySearch(arr,1, 3, 10);
int index9 = Arrays.binarySearch(arr,1, 3, 0);
System.out.println("index5 = "+ index5 +", index6 = " + index6 +
 ", index7 = " + index7 +", index8 = "+ index8 +
", index9 = " + index9);
>>>>>index5 = -5, index6 = 2,index7 = -2, index8 = -4, index9 = -2

第八章 数字处理类
Java中为了处理数学、随机、金融等数字问题，封装了一些类。

8.1 DecimalFormat类（格式化数字）
Java主要对浮点型数据进行数字格式化，包括double和float型。Java未格式化数据遵循以下原则：
绝对值在e-3到e7之间的数值以常规小数形式表示。在此之外以科学计数法表示。
除此之外可以使用DecimalFormat类：java.text.DecimalFormat。
该类是NumberFormat类的子类，用于格式化十进制数字，可以转换为整数，浮点数，百分数等。可以向其传入数字格式，格式化数字可以利用该类中的一些特殊字符造成一个格式化模板，使数字按照一定模式进行匹配。

特殊符号：
0 一个数字，如果该位不存在数字就显示0。
# 一个数字，不包括 0。
. 小数的分隔符的占位符。
, 分组分隔符的占位符。
; 分隔格式。
- 缺省负数前缀。
% 乘以 100 和作为百分比显示。
\u2030 乘以 1000 和作为千进制显示。
\u00A4 本符号放置在数字的前缀或者后缀，作为货币记号。
X 前缀或后缀中使用的任何其它字符，用来引用前缀或后缀中的特殊字符。
E 分隔科学记数法中的尾数和指数。
' 转义字符，当出现特殊符号，放在前面以转义。

类的使用方法：
①format()方法：
格式：
DecimalFormat 格式模板变量名 = new DecimalFormat(格式模板字符串);
String 保存格式化变量名 = 格式模板变量名.format(目标数据);
如：
DecimalFormat df1 = new DecimalFormat("0.0");
　　DecimalFormat df2 = new DecimalFormat("#.#");
　　DecimalFormat df3 = new DecimalFormat("000.000");
　　DecimalFormat df4 = new DecimalFormat("###.###");
　　System.out.println(df1.format(12.34));
　　System.out.println(df2.format(12.34));
　　System.out.println(df3.format(12.34));
　　System.out.println(df4.format(12.34));
>>>>>　
12.3
12.3
012.340
12.34

格式：
String 保存格式化变量名 = new DecimalFormat(格式模板字符串).format(目标数据)
如；
importjava.text.DecimalFormat;    
publicclassTestNumberFormat{   
　　publicstaticvoidmain(String[]args){  
　　　　double pi=3.1415927;　//圆周率  
　　　　//取一位整数  
　　　　System.out.println(new DecimalFormat("0").format(pi));　　　//3  
　　　　//取一位整数和两位小数  
　　　　System.out.println(new DecimalFormat("0.00").format(pi));　//3.14  
　　　　//取两位整数和三位小数，整数不足部分以0填补。  
　　　　System.out.println(new DecimalFormat("00.000").format(pi));// 03.142  
　　　　//取所有整数部分  
　　　　System.out.println(newDecimalFormat("#").format(pi));　　　//3  
　　　　//以百分比方式计数，并取两位小数  
　　　　System.out.println(new DecimalFormat("#.##%").format(pi));　//314.16%  
　　　　long c=299792458;　　//光速  
　　　　//显示为科学计数法，并取五位小数  
　　　　System.out.println(newDecimalFormat("#.#####E0").format(c));　//2.99792E8  
　　　　//显示为两位整数的科学计数法，并取四位小数  
　　　　System.out.println(newDecimalFormat("00.####E0").format(c));　//29.9792E7  
　　　　//每三位以逗号进行分隔。  
　　　　System.out.println(newDecimalFormat(",###").format(c));　　　//299,792,458  
　　　　//将格式嵌入文本  
　　　　System.out.println(newDecimalFormat("每秒###\米。").format(c));  
　　}  
}
②setGroupingSize()方法
package test;
import java.text.DecimalFormat;
public class DecimalMethod {
    public static void main(String[] args) {
        DecimalFormat myFormat = new DecimalFormat();
        myFormat.setGroupingSize(2);//将数字以每两个数字分组(整数部分)
        String output = myFormat.format(123456.789);
        System.out.println("将数字以每两个数字分组："+output);
        myFormat.setGroupingUsed(false);//设置不允许数字进行分组
        String output2 = myFormat.format(123456.789);
        System.out.println("不允许数字分组"+output2);
    }
}
>>>>>
将数字以每两个数字分组：12,34,56.789
不允许数组分组：123456.789

8.2 Math类（数学运算）
Math类提供了许多数学函数方法，被定义为static形式，可以通过Math.数学方法的形式调用。

8.2.1数学常量
Math.PI：圆周率；
Math.E：自然对数；

8.2.2常用数学方法
8.2.2.1三角函数
sin(角度/弧度)：正弦函数；
cos(角度/弧度)：余弦函数；
tan(角度/弧度)：正切函数；
asin(角度/弧度)：反正弦函数；
acos(角度/弧度)：反余弦函数；
atan(角度/弧度)：反正切函数；
toRadians(角度)：将角度转换为弧度函数；
toDegrees(弧度)：将弧度转换为角度函数；
三角函数参数和返回值都是double类型的。

8.2.2.2指数函数
exp(值)：取e的参数值次方，即取e^值；
log(值)：取自然对数，即取ln值；
log10(值)：取底数为10的对数；
sqrt(值)：取值的平方根，值不能为负数；
cbrt(值)：取值的立方根；
pow(值a,值b)：取a的b次方；
指数函数的参数和返回值也都是double类型的。

8.2.2.3取整函数
ceil(值)：返回大于等于参数的最小整数；
floor(值)：返回小于等于参数的最大整数；
rint(值)：返回与参数最接近的整数，如果两个同为整数且同样接近，取偶数。
这三个方法的参数和返回值都是double类型。

round(值)：将float型参数加上0.5后返回与参数最接近的int型整数。
round(值)：将double型参数加上0.5后返回与参数最接近的long型整数。

8.2.2.4最值绝对值函数
max(值a,值b)：取ab之间的最大值，a，b和返回值都是double型。
min(值a,值b)：取ab之间的最小值，a，b是什么类型返回值就是什么类型，可以为int、long、float和double型数据。
abs(值)：取值的绝对值，参数是什么类型返回值就是什么类型。

8.2.3随机数
用于产生随机数字，默认生成大于等于0.0且小于1.0的double型随机数。
(int)(Math.random()*n)>>>>>返回大于等于0且小于n的随机数；
m+(int)(Math.random()*n)>>>>>返回大于等于m且小于m+n的随机数；
(char)('a'+Math.random()*('z'-'a'+1))>>>>>随机生成a到z的字符；
(char)('A'+Math.random()*('R'-'A'+1))>>>>>随机生成A到R的字符；
8.2.4大整数运算（BigInteger类）
格式：BigInteger 变量名 = new BigInteger(字符串);
使用 变量名.方法名()的格式对大整数进行运算。

add(值)：加法运算；
subtract(值)：减法运算；
multiply(值)：乘法运算；
divide(值)：除法运算；
remainder(值)：取余运算；
divideAndRemainder(值)：用BigInteger数组返回余数和商，结果数组中第一个值为商，第二个值为余数；
其参数值和返回值都是BigInteger类。

pow(整数值)：对参数进行整数值次方操作；
negate()：取反操作；
shiftLeft(n)：将数字左移n位，如果n是负数则右移；
shiftRight(n)：将数字右移n位，如果n为负数则左移；

and(值)：做与操作；
or(值)：做或操作；
max(值)：返回较大值；
min(值)：返回较小值；
其参数值和返回值都是BigInteger类。

compareTo(值)：做数字比较操作，返回值int类型；
equals(值)：当参数值为BigInteger类型的数字且数值相等时，才返回true，否则返回false。

8.2.5大小数运算（BigDeciaml类）
格式：BigDeciaml 变量名 = new BigDeciaml(字符串);
/BigDeciaml 变量名 = new BigDeciaml(双精度浮点数);
使用 变量名.方法名()的格式对大小数进行运算。

add(值)：加法运算；
subtract(值)：减法运算；
multiply(值)：乘法运算；
divide(除数,商小数点后的位数,近似处理模式)：除法运算；

divide()的处理模式：
BigDecimal.ROUND_UP：商的最后一位如果大于0，就向前进位，无论负数正数都是如此；
BigDecimal.ROUND_DOWN：商的最后一位无论什么数字都省略；
BigDecimal.ROUND_CEILING：商如果是正数就按照ROUND_UP模式处理，如果是负数就是按照ROUND_DOWN模式处理，这种处理模式是商的近似值使用大于或者等于实际值。
BigDecimal.ROUND_FLOOR：商如果是正数就按照ROUND_DOWN模式处理，如果是负数就是按照ROUND_UP模式处理，这种处理模式是商的近似值使用小于于或者等于实际值。
BigDecimal.ROUND_HALF_DOWN：对商进行四舍五入操作，如果商小于等于5就舍弃，如果大于5就进位； 如：7.5>>>>>7
BigDecimal.ROUND_HALF_UP：对商进行四舍五入操作，如果商小于5就舍弃，如果大于等于5就进位； 如：7.5>>>>>8
BigDecimal.ROUND_HALF_EVEN：如果商的倒数第二位是奇数就按照ROUND_HALF_UP处理，如果是偶数，就按照HALF_DOWN处理；

其参数值和返回值都是BigInteger类。

8.3 Random类
除了使用Math类中的random()方法外，还可以使用java.util.Random类。实例化一个Random对象创建一个随机数生成器。
格式：Random 随机数生成器名 = new Random();
这种创建方式下Java编译器将以系统当前时间作为随机数生成器的种子，来产生随机数，如果运行速度过快也可能出现同样的随机数。
也可以传入随机数生成器的种子作为函数参数。

还有一些返回值格式方法，以
随机数生成器名.方法名(); 的方式调用：
nextInt()：返回一个随机整数；
nextInt(整数n)：返回一个大于等于0小于n的随机整数；
nextLong()：返回一个随机长整型数；
nextBoolean()：返回一个随机布尔值；
nextFloat()：返回一个随机单精度浮点型值；
nextDouble()：返回一个随机双精度浮点型；
nextGaussian()：返回一个概率密度为高斯分布的双精度值。

 -->

---

## [回到目录](#目录) &emsp; &emsp;[查询更多](https://github.com/Didnelpsun/notes)

### 参考

1. 
